# -*- coding: utf-8 -*-
"""02122025 dIAbetes_Classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18M0u4E72BZ7OYKY_DiLGSiaRfwpRpDun

# Será que tiene d***IA***betes?

# Predicción del diagostico de dIAbetes haciendo uso de diferentes algoritmos de clasificación
Objetivo del Ejercicio: `Predecir` si un paciente tiene dIAbetes partiendo del comportamiento de variables como: ![image.png](data:image/png;base64,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).
![dataset-cover.jpg](data:image/jpeg;base64,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)

**Diccionario de Significado de variables**

* "age": "Edad del paciente",
  * "gender": "Género del paciente",
  * "ethnicity": "Origen étnico del paciente",
  * "education_level": "Nivel educativo del paciente",
  * "income_level": "Nivel de ingresos del paciente",
  * "employment_status": "Estado laboral del paciente",
  * "smoking_status": "Estado de tabaquismo del paciente",
  * "alcohol_consumption_per_week": "Consumo de alcohol del paciente por semana",
  * "physical_activity_minutes_per_week": "Minutos de actividad física del paciente por semana",
  * "diet_score": "Puntuación de la dieta del paciente",
  * "sleep_hours_per_day": "Horas de sueño del paciente por día",
  * "screen_time_hours_per_day": "Horas de tiempo de pantalla del paciente por día",
  * "family_history_diabetes": "Historial familiar de diabetes (1 si lo tiene, 0 si no)",
  * "hypertension_history": "Historial de hipertensión (1 si lo tiene, 0 si no)",
  * "cardiovascular_history": "Historial de enfermedades cardiovasculares (1 si lo tiene, 0 si no)",
  * "bmi": "Índice de Masa Corporal (IMC) del paciente",
  * "waist_to_hip_ratio": "Relación cintura-cadera del paciente",
  * "systolic_bp": "Presión arterial sistólica del paciente",
  * "diastolic_bp": "Presión arterial diastólica del paciente",
  * "heart_rate": "Frecuencia cardíaca del paciente",
  * "cholesterol_total": "Nivel de colesterol total del paciente",
  * "hdl_cholesterol": "Nivel de colesterol HDL (colesterol bueno) del paciente",
  * "ldl_cholesterol": "Nivel de colesterol LDL (colesterol malo) del paciente",
  * "triglycerides": "Nivel de triglicéridos del paciente",
  * "glucose_fasting": "Nivel de glucosa en ayunas del paciente",
  * "glucose_postprandial": "Nivel de glucosa posprandial del paciente",
  * "insulin_level": "Nivel de insulina del paciente",
  * "hba1c": "Nivel de HbA1c (hemoglobina glicosilada) del paciente",
  * "diabetes_risk_score": "Puntuación de riesgo de diabetes del paciente",
  * "diabetes_stage": "Etapa de la diabetes del paciente (e.g., No Diabetes, Pre-Diabetes, Type 1, Type 2)",
  * "diagnosed_diabetes": "Diagnóstico final de diabetes (1 si tiene diabetes, 0 si no)"

## 1.RECOLECCIÓN DE DATOS
1.1 Importar y Leer el DataSet
"""

# Librerias para manipulacion de Data y Gráficas
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

#Preparación de datos y configuración de pipeline para Machine Learning con scikit-learn
from sklearn.pipeline import make_pipeline
from sklearn.model_selection import train_test_split
from sklearn.model_selection import validation_curve
from sklearn.model_selection import cross_val_score
from sklearn.compose import ColumnTransformer, make_column_transformer
from sklearn.preprocessing import StandardScaler, OneHotEncoder, LabelEncoder

#models
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures
from sklearn.ensemble import RandomForestClassifier
from sklearn.ensemble import RandomForestRegressor
from sklearn.neighbors import KNeighborsClassifier
from sklearn.neighbors import KNeighborsRegressor
from sklearn.tree import DecisionTreeClassifier
from sklearn.tree import DecisionTreeRegressor
from sklearn.linear_model import LogisticRegression
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score, roc_auc_score
#for classification
from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix
from sklearn.ensemble import HistGradientBoostingClassifier
from sklearn.svm import SVC
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.linear_model import SGDClassifier
from sklearn.ensemble import ExtraTreesClassifier

#for regression
from sklearn.metrics import r2_score

#Balanceo de datos
from imblearn.over_sampling import SMOTE
from imblearn.under_sampling import RandomUnderSampler
from imblearn.combine import SMOTETomek

#Leer el DataSet
data_diabetes = pd.read_csv('dIAbetes.csv')
data_diabetes

"""## 2. PIPELINE/ANÁLISIS EXPLORATORIO DE DATOS (EDA)

### Comprendiendo los Datos
"""

#Entender y conocer el dataset
data_diabetes.info()

#Identificar si tenemos datos nulos
data_diabetes.isnull().sum() # Alternativa para ver datos nulos

# Mostrar las primeras filas del Dataframe para ir reconociendo la dataframe
data_diabetes.head(10)

"""### Aplicar One-Hot Encoding a las variables categóricas: Etnia, Género y Tabaquismo"""

# Create a copy of the DataFrame original para no modificar los datos originales directamente
data_encoded_diabetes = data_diabetes.copy()

# Aplica One-Hot Encoding a las columnas especificadas, conservando todas las categorías
data_encoded_diabetes = pd.get_dummies(data_encoded_diabetes, columns=['gender', 'ethnicity', 'smoking_status'], drop_first=False, dtype=int)

# Mueve la columna 'diagnosed_diabetes' al final
diagnosed_diabetes_col = data_encoded_diabetes.pop('diagnosed_diabetes')
data_encoded_diabetes['diagnosed_diabetes'] = diagnosed_diabetes_col

# Muestra las primeras filas del DataFrame codificado
print("Primeras filas del DataFrame 'data_encoded_diabetes' después de la codificación one-hot numérica y reordenación de columna:")
display(data_encoded_diabetes.head())

"""### Conteo de datos en la variable objeto"""

# Contar la cantidad de 1s y 0s en la columna ''
diagnosed_diabetes_counts = data_encoded_diabetes['diagnosed_diabetes'].value_counts()
diagnosed_diabetes_counts

"""### Creamos la Matriz de Correlación"""

# Analizar la correlación de las caracteristicas con respecto a la columna objetivo.
plt.figure(figsize=(30,30))
sns.heatmap(data_encoded_diabetes.corr(),annot=True)

"""### Data Visualización"""

plt.figure(figsize=(10,4)) #esta grafica ,muestra que cuando se tiene dIAbetes color naranja la  glucose_fasting esta alta

plt.subplot(1,2,1)
plt.title('glucose_postprandial and glucose_fasting')
sns.scatterplot(x=data_encoded_diabetes['glucose_postprandial'],y=data_encoded_diabetes['glucose_fasting'],hue=data_encoded_diabetes['diagnosed_diabetes']);

plt.subplot(1,2,2)
plt.title('glucose_postprandial and glucose_fasting')
sns.kdeplot(x=data_encoded_diabetes['glucose_postprandial'],y=data_encoded_diabetes['glucose_fasting'],hue=data_encoded_diabetes['diagnosed_diabetes']);

"""Separación clara de clases: Los pacientes con diabetes (naranja) se concentran en valores >126 mg/dL en ayunas y >140 mg/dL postprandial
Zona de solapamiento: Existe un área de mezcla entre 100-126 mg/dL (ayunas) que representa prediabetes
Patrón lineal fuerte: La correlación alta (~0.60-0.70) indica que ambas mediciones están relacionadas pero aportan información complementaria
"""

plt.figure(figsize=(12,4)) #esta grafica ,muestra que cuando se tiene dIAbetes color naranja el  hba1c esta bajo

plt.subplot(1,2,1)
plt.title('glucose_fasting and hba1c')
sns.scatterplot(x=data_encoded_diabetes['glucose_fasting'],y=data_encoded_diabetes['hba1c'],hue=data_encoded_diabetes['diagnosed_diabetes']);

plt.subplot(1,2,2)
plt.title('glucose_fasting and hba1c')
sns.kdeplot(x=data_encoded_diabetes['glucose_fasting'],y=data_encoded_diabetes['hba1c'],hue=data_encoded_diabetes['diagnosed_diabetes']);

"""Separación aún más clara: HbA1c >6.5% es el criterio diagnóstico gold standard
Menos solapamiento: Las distribuciones están más diferenciadas que en la primera gráfica
Relación fisiológica: HbA1c refleja promedio de glucosa de 2-3 meses, explicando la correlación
"""

plt.figure(figsize=(12,4)) #esta grafica ,muestra que cuando se tiene dIAbetes color naranja el  waist_to_hip_ratio esta bajo

plt.subplot(1,2,1)
plt.title('waist_to_hip_ratio and bmi')
sns.scatterplot(x=data_encoded_diabetes['waist_to_hip_ratio'],y=data_encoded_diabetes['bmi'],hue=data_encoded_diabetes['diagnosed_diabetes']);

plt.subplot(1,2,2)
plt.title('waist_to_hip_ratio and bmi')
sns.kdeplot(x=data_encoded_diabetes['waist_to_hip_ratio'],y=data_encoded_diabetes['bmi'],hue=data_encoded_diabetes['diagnosed_diabetes']);

"""Solapamiento masivo: Ambas clases están mezcladas en todo el rango
No hay separación clara: Pacientes diabéticos y no diabéticos tienen distribuciones similares
Baja capacidad discriminativa individual: Aunque el BMI tenía correlación 0.30, por sí solo no separa bien
"""

data_encoded_diabetes.hist(bins=50, figsize=(20,15))
plt.show()

"""1. VARIABLES CONTINUAS - DISTRIBUCIÓN NORMALVariables con distribución aproximadamente normal:

✅ age: Campana bien formada, centrada ~50 años
✅ bmi: Distribución normal, centro ~27-28 (sobrepeso)
✅ diet_score: Normal, centro ~5-6
✅ sleep_hours_per_day: Normal, centro ~7 horas
✅ glucose_fasting: Bimodal pero simétrica
✅ glucose_postprandial: Bimodal pero simétrica
✅ triglycerides: Ligeramente sesgada a la derecha
✅ cholesterol_total: Normal
✅ hba1c: Distribución bimodal (diabéticos vs no diabéticos)

Estas variables están bien escaladas y no requieren transformaciones agresivas- No hay outliers extremos evidentes

## PAIRPLOT COMPACTO - TOP 4 VARIABLES
"""

import os # Import the os module

# Las 4 variables con mayor correlación con diabetes
top_4_variables = [
    'glucose_postprandial',
    'glucose_fasting',
    'hba1c',
    'bmi',
    'diagnosed_diabetes'
]

print(f"\nCreating compact pairplot (top 4 variables)...")

df_compact_diabetes = data_encoded_diabetes[top_4_variables]

plt.figure(figsize=(12, 10))
pairplot_compact = sns.pairplot(
    df_compact_diabetes,
    hue='diagnosed_diabetes',
    palette=['#3498db', '#e74c3c'],  # Azul y rojo
    diag_kind='kde',  # KDE en diagonal (más suave que histograma)
    plot_kws={'alpha': 0.5, 's': 15},
    diag_kws={'shade': True, 'linewidth': 2}
)

pairplot_compact.fig.suptitle('Pairplot - Top 4 Predictors',
                              fontsize=16, fontweight='bold', y=1.00)

# Mejorar leyenda
handles = pairplot_compact._legend_data.values()
labels = ['No Diabetes (0)', 'Diabetes (1)']
pairplot_compact.fig.legend(handles=handles, labels=labels,
                            loc='upper right', frameon=True,
                            title='Diagnosis', fontsize=11)

plt.tight_layout()

# Create the directory if it doesn't exist
output_dir = '/mnt/user-data/outputs/'
os.makedirs(output_dir, exist_ok=True)

plt.savefig(os.path.join(output_dir, 'pairplot_top4.png'),
            dpi=300, bbox_inches='tight')
plt.show()

print("\n✓ Compact pairplot completed!")

# ============================================
# BOXPLOTS PROFESIONALES - VERSIÓN FINAL
# ============================================

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
import warnings
warnings.filterwarnings('ignore')

print("="*80)
print("PROFESSIONAL BOXPLOT ANALYSIS")
print("="*80)

# ============================================
# CONFIGURACIÓN
# ============================================

# Variables clave
variables_to_plot = [
    'glucose_postprandial',
    'glucose_fasting',
    'hba1c',
    'bmi',
    'age',
    'insulin_level'
]

# Configurar estilo
sns.set_style("whitegrid")
sns.set_context("notebook", font_scale=1.0)

# ============================================
# FIGURA 1: BOXPLOT + VIOLINPLOT HÍBRIDO
# ============================================

print("\nCreating hybrid boxplot-violinplot...")

# Create df_compact_diabetes including all variables to plot plus the target
df_compact_diabetes = data_encoded_diabetes[variables_to_plot + ['diagnosed_diabetes']]

# Layout
n_vars = len(variables_to_plot)
n_cols = 3
n_rows = (n_vars + n_cols - 1) // n_cols

# Crear figura
fig, axes = plt.subplots(n_rows, n_cols, figsize=(18, 6*n_rows))
axes = axes.flatten()

# Colores
colors = ['#3498db', '#e74c3c']

for idx, var in enumerate(variables_to_plot):
    ax = axes[idx]

    # Violinplot
    sns.violinplot(
        data=df_compact_diabetes,
        x='diagnosed_diabetes',
        y=var,
        ax=ax,
        palette=colors,
        inner=None,
        alpha=0.4,
        linewidth=1.5,
        hue='diagnosed_diabetes',
        legend=False
    )

    # Boxplot encima
    sns.boxplot(
        data=df_compact_diabetes,
        x='diagnosed_diabetes',
        y=var,
        ax=ax,
        width=0.3,
        palette=colors,
        showcaps=True,
        boxprops=dict(linewidth=2, edgecolor='black'),
        whiskerprops=dict(linewidth=2, color='black'),
        capprops=dict(linewidth=2, color='black'),
        medianprops=dict(linewidth=3, color='white'),
        flierprops=dict(marker='o', markersize=5, markerfacecolor='gray',
                       markeredgecolor='black', alpha=0.5),
        hue='diagnosed_diabetes',
        legend=False
    )

    # Personalizar
    ax.set_title(f'{var}', fontsize=14, fontweight='bold', pad=12)
    ax.set_xlabel('Diagnosis', fontsize=12, fontweight='bold')
    ax.set_ylabel(var, fontsize=12, fontweight='bold')
    ax.set_xticklabels(['No Diabetes (0)', 'Diabetes (1)'], fontsize=11)
    ax.grid(True, alpha=0.25, linestyle='--', linewidth=0.5, axis='y')

    # Calcular estadísticas
    no_diab = df_compact_diabetes[df_compact_diabetes['diagnosed_diabetes'] == 0][var]
    diab = df_compact_diabetes[df_compact_diabetes['diagnosed_diabetes'] == 1][var]

    median_0 = no_diab.median()
    median_1 = diab.median()
    diff = median_1 - median_0
    pct = (diff / median_0 * 100) if median_0 != 0 else 0

    # Test estadístico
    stat, p_value = stats.mannwhitneyu(no_diab, diab, alternative='two-sided')

    # Significancia
    if p_value < 0.001:
        sig = '***'
    elif p_value < 0.01:
        sig = '**'
    elif p_value < 0.05:
        sig = '*'
    else:
        sig = 'ns'

    # Color según significancia
    if p_value < 0.001:
        bg_color = '#ffcccc'
    elif p_value < 0.05:
        bg_color = '#fff4cc'
    else:
        bg_color = '#e8e8e8'

    # Anotación
    annotation_text = f'Δ: {diff:.1f} ({pct:+.1f}%)\np {sig}'

    ax.text(
        0.98, 0.98,
        annotation_text,
        transform=ax.transAxes,
        fontsize=10,
        verticalalignment='top',
        horizontalalignment='right',
        bbox=dict(boxstyle='round,pad=0.5', facecolor=bg_color,
                 alpha=0.85, edgecolor='black', linewidth=1.5),
        fontweight='bold'
    )

    # Imprimir
    print(f"\n{var}:")
    print(f"  No Diabetes - Median: {median_0:.2f}")
    print(f"  Diabetes    - Median: {median_1:.2f}")
    print(f"  Difference: {diff:+.2f} ({pct:+.1f}%)")
    print(f"  p-value: {p_value:.4f} {sig}")

# Ocultar ejes vacíos
for idx in range(n_vars, len(axes)):
    axes[idx].axis('off')

# Título
plt.suptitle('Boxplot-Violin Hybrid Analysis - Diabetes Predictors',
             fontsize=20, fontweight='bold', y=0.995)

plt.tight_layout()
plt.savefig('/mnt/user-data/outputs/boxplot_violin_hybrid.png', dpi=300, bbox_inches='tight')
plt.show()

print("\n✓ Hybrid boxplot created successfully!")

# ============================================
# FIGURA 2: TOP 4 COMPACTO
# ============================================

print("\nCreating compact top-4 boxplot...")

top_4_vars = ['glucose_postprandial', 'glucose_fasting', 'hba1c', 'bmi']

fig, axes = plt.subplots(1, 4, figsize=(20, 5))

for idx, var in enumerate(top_4_vars):
    ax = axes[idx]

    # Violinplot
    sns.violinplot(
        data=df_compact_diabetes,
        x='diagnosed_diabetes',
        y=var,
        ax=ax,
        palette=colors,
        inner=None,
        alpha=0.3,
        hue='diagnosed_diabetes',
        legend=False
    )

    # Boxplot
    sns.boxplot(
        data=df_compact_diabetes,
        x='diagnosed_diabetes',
        y=var,
        ax=ax,
        width=0.25,
        palette=colors,
        showcaps=True,
        boxprops=dict(linewidth=2.5),
        medianprops=dict(linewidth=3, color='white'),
        whiskerprops=dict(linewidth=2),
        capprops=dict(linewidth=2),
        flierprops=dict(marker='o', markersize=4, alpha=0.4),
        hue='diagnosed_diabetes',
        legend=False
    )

    # Personalizar
    ax.set_title(f'{var}', fontsize=15, fontweight='bold', pad=10)
    ax.set_xlabel('Diagnosis', fontsize=13, fontweight='bold')
    ax.set_ylabel(var, fontsize=13)
    ax.set_xticklabels(['No\nDiabetes', 'Diabetes'], fontsize=12)
    ax.grid(True, alpha=0.25, axis='y')

plt.suptitle('Top 4 Diabetes Predictors - Compact View',
             fontsize=18, fontweight='bold', y=1.02)

plt.tight_layout()
plt.savefig('/mnt/user-data/outputs/boxplot_top4_compact.png', dpi=300, bbox_inches='tight')
plt.show()

print("\n✓ Compact boxplot created successfully!")

# ============================================
# TABLA ESTADÍSTICA
# ============================================

print("\nGenerating statistical summary...")

summary_data = []

for var in variables_to_plot:
    no_diab = df_compact_diabetes[df_compact_diabetes['diagnosed_diabetes'] == 0][var]
    diab = df_compact_diabetes[df_compact_diabetes['diagnosed_diabetes'] == 1][var]

    stat, p_value = stats.mannwhitneyu(no_diab, diab, alternative='two-sided')

    # CORRECCIÓN: Cohen's d en una sola línea
    mean_diff = diab.mean() - no_diab.mean()
    pooled_std = np.sqrt((diab.std()**2 + no_diab.std()**2) / 2)
    cohens_d = mean_diff / pooled_std

    summary_data.append({
        'Variable': var,
        'No_Diabetes_Median': no_diab.median(),
        'Diabetes_Median': diab.median(),
        'Median_Diff': diab.median() - no_diab.median(),
        'Percent_Change': ((diab.median() - no_diab.median()) / no_diab.median() * 100) if no_diab.median() != 0 else 0,
        'P_Value': p_value,
        'Cohens_D': cohens_d,
        'Significance': '***' if p_value < 0.001 else ('**' if p_value < 0.01 else ('*' if p_value < 0.05 else 'ns'))
    })

summary_df = pd.DataFrame(summary_data)
summary_df = summary_df.sort_values('Cohens_D', key=abs, ascending=False)

print("\n" + "="*80)
print("STATISTICAL SUMMARY")
print("="*80)
display(summary_df.round(3))

# Guardar
summary_df.to_csv('/mnt/user-data/outputs/boxplot_statistical_summary.csv', index=False)

print("\n✓ Statistical summary saved!")

# ============================================
# RESUMEN
# ============================================

print("\n" + "="*80)
print("BOXPLOT ANALYSIS COMPLETED!")
print("="*80)

print(f"""
FILES GENERATED:
✓ boxplot_violin_hybrid.png
✓ boxplot_top4_compact.png
✓ boxplot_statistical_summary.csv

SUMMARY:
- Variables analyzed: {len(variables_to_plot)}
- Significant differences (p<0.05): {len(summary_df[summary_df['P_Value'] < 0.05])}
- Highly significant (p<0.001): {len(summary_df[summary_df['P_Value'] < 0.001])}

TOP 3 PREDICTORS (by effect size):
1. {summary_df.iloc[0]['Variable']} (Cohen's d = {summary_df.iloc[0]['Cohens_D']:.2f})
2. {summary_df.iloc[1]['Variable']} (Cohen's d = {summary_df.iloc[1]['Cohens_D']:.2f})
3. {summary_df.iloc[2]['Variable']} (Cohen's d = {summary_df.iloc[2]['Cohens_D']:.2f})
""")

print("="*80)
print("🎉 ALL DONE!")
print("="*80)

"""# **Categoría Sin Balanceo**"""

#División de datos
X = data_encoded_diabetes.drop(['diagnosed_diabetes'],axis=1)
y = data_encoded_diabetes['diagnosed_diabetes']
X_train, X_test, y_train, y_test = train_test_split(X,y,train_size=0.7) # 70% Train y 30% Test

"""## Regresion Logistica"""

# Definir y entrenar el modelo
model_LR = LogisticRegression()
model_LR.fit(X_train,y_train)

#Predicciones
y_predict_LR = model_LR.predict(X_test)

#Matriz de confusión
accuracy = accuracy_score(y_test,y_predict_LR)
print('The accuracy of Logistic Regression is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test,y_predict_LR)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['LogisticRegression'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_LR, FP_LR, FN_LR, TP_LR = confus_matrix.ravel()
print(TN_LR, FP_LR, FN_LR, TP_LR)

# Calcular métricas derivadas
accuracy_LR = accuracy_score(y_test, y_predict_LR)
precision_LR = precision_score(y_test, y_predict_LR)
recall_LR = recall_score(y_test, y_predict_LR)
specificity_LR = TN_LR / (TN_LR + FP_LR)
f1_LR = f1_score(y_test, y_predict_LR)

y_proba_LR = model_LR.predict_proba(X_test)[:, 1]
roc_auc_LR = roc_auc_score(y_test, y_proba_LR)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_LR:.4f}")
print(f"🔹 Precision (PPV): {precision_LR:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_LR:.4f}")
print(f"🔹 Specificity (TNR): {specificity_LR:.4f}")
print(f"🔹 F1-Score: {f1_LR:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_LR:.4f}")

"""## **HistGradientBoosting**"""

# Definir y entrenar el modelo
model_HGBoost = HistGradientBoostingClassifier()
model_HGBoost.fit(X_train,y_train)

#Predicciones
y_predict_HGBoost = model_HGBoost.predict(X_test)

accuracy = accuracy_score(y_test,y_predict_HGBoost)
print('The accuracy of Logistic Regression is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test,y_predict_HGBoost)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['LogisticRegression'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_HGBoost, FP_HGBoost, FN_HGBoost, TP_HGBoost = confus_matrix.ravel()
print(TN_HGBoost, FP_HGBoost, FN_HGBoost, TP_HGBoost)

# Calcular métricas derivadas
accuracy_HGBoost = accuracy_score(y_test, y_predict_HGBoost)
precision_HGBoost = precision_score(y_test, y_predict_HGBoost)
recall_HGBoost = recall_score(y_test, y_predict_HGBoost)
specificity_HGBoost = TN_HGBoost / (TN_HGBoost + FP_HGBoost)
f1_HGBoost = f1_score(y_test, y_predict_HGBoost)

y_proba_HGBoost = model_HGBoost.predict_proba(X_test)[:, 1]
roc_auc_HGBoost = roc_auc_score(y_test, y_proba_HGBoost)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_HGBoost:.4f}")
print(f"🔹 Precision (PPV): {precision_HGBoost:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_HGBoost:.4f}")
print(f"🔹 Specificity (TNR): {specificity_HGBoost:.4f}")
print(f"🔹 F1-Score: {f1_HGBoost:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_HGBoost:.4f}")

"""## KNeighbors KNN"""

# Definir y entrenar el modelo
model_KNN = KNeighborsClassifier()
# Entrenar Modelo
model_KNN.fit(X_train,y_train)

# Predicciones
y_predict_KNN = model_KNN.predict(X_test)

accuracy_KNN = accuracy_score(y_test,y_predict_KNN)
print('The accuracy of KNN is {:.4f}'.format(accuracy_KNN))

confus_matrix_KNN = confusion_matrix(y_test,y_predict_KNN)
plt.title('Confusion matrix KNN')
sns.heatmap(confus_matrix_KNN, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie_KNN = pd.Series(accuracy_KNN,index=['KNN'])
accuracy_KNNmodel_KNN = pd.DataFrame({'accuracy':serie_KNN})

# Extraer valores de la matriz de confusión
TN_KNN, FP_KNN, FN_KNN, TP_KNN = confus_matrix_KNN.ravel()

# Calcular métricas derivadas
accuracy_KNN = accuracy_score(y_test, y_predict_KNN)
precision_KNN = precision_score(y_test, y_predict_KNN)
recall_KNN = recall_score(y_test, y_predict_KNN)
specificity_KNN = TN_KNN / (TN_KNN + FP_KNN)
f1_KNN = f1_score(y_test, y_predict_KNN)

y_proba_KNN = model_KNN.predict_proba(X_test)[:, 1]
roc_auc_KNN = roc_auc_score(y_test, y_proba_KNN)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_KNN:.4f}")
print(f"🔹 Precision (PPV): {precision_KNN:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_KNN:.4f}")
print(f"🔹 Specificity (TNR): {specificity_KNN:.4f}")
print(f"🔹 F1-Score: {f1_KNN:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_KNN:.4f}")

"""## Decision tree Application"""

# Definir y entrenar el modelo
model_DT = DecisionTreeClassifier()
# Entrenar Modelo
model_DT.fit(X_train,y_train)

# Predicciones
y_predict_DT = model_DT.predict(X_test)

# Generamos la Matriz de Confusión
accuracy_DT = accuracy_score(y_test,y_predict_DT)
print('The accuracy of DT is {:.4f}'.format(accuracy_DT))

confus_matrix_DT = confusion_matrix(y_test,y_predict_DT)
plt.title('Confusion matrix DT')
sns.heatmap(confus_matrix_DT, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie_DT = pd.Series(accuracy_DT,index=['DT'])
accuracy_model_DT = pd.DataFrame({'accuracy':serie_DT})

# Extraer valores de la matriz de confusión
TN_DT, FP_DT, FN_DT, TP_DT = confus_matrix_DT.ravel()

# Calcular métricas derivadas
accuracy_DT = accuracy_score(y_test, y_predict_DT)
precision_DT = precision_score(y_test, y_predict_DT)
recall_DT = recall_score(y_test, y_predict_DT)
specificity_DT = TN_DT / (TN_DT + FP_DT)
f1_DT = f1_score(y_test, y_predict_DT)

y_proba_DT = model_DT.predict_proba(X_test)[:, 1]
roc_auc_DT = roc_auc_score(y_test, y_proba_DT)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_DT:.4f}")
print(f"🔹 Precision (PPV): {precision_DT:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_DT:.4f}")
print(f"🔹 Specificity (TNR): {specificity_DT:.4f}")
print(f"🔹 F1-Score: {f1_DT:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_DT:.4f}")

"""## Random Forest"""

# Definicion y construccion del modelo
model_RF = RandomForestClassifier()
# Entrenar Modelo
model_RF.fit(X_train,y_train)

# Predicciones
y_predict_RF = model_RF.predict(X_test)

accuracy_RF = accuracy_score(y_test,y_predict_RF)
print('The accuracy of RF is {:.4f}'.format(accuracy_RF))

confus_matrix_RF = confusion_matrix(y_test,y_predict_RF)
plt.title('Confusion matrix RF')
sns.heatmap(confus_matrix_RF, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie_RF = pd.Series(accuracy_RF,index=['RF'])
accuracy_model_RF = pd.DataFrame({'accuracy':serie_RF})

# Extraer valores de la matriz de confusión
TN_RF, FP_RF, FN_RF, TP_RF = confus_matrix_RF.ravel()

# Calcular métricas derivadas
accuracy_RF = accuracy_score(y_test, y_predict_RF)
precision_RF = precision_score(y_test, y_predict_RF)
recall_RF = recall_score(y_test, y_predict_RF)
specificity_RF = TN_RF / (TN_RF + FP_RF)
f1_RF = f1_score(y_test, y_predict_RF)

y_proba_RF = model_RF.predict_proba(X_test)[:, 1]
roc_auc_RF = roc_auc_score(y_test, y_proba_RF)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_RF:.4f}")
print(f"🔹 Precision (PPV): {precision_RF:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_RF:.4f}")
print(f"🔹 Specificity (TNR): {specificity_RF:.4f}")
print(f"🔹 F1-Score: {f1_RF:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_RF:.4f}")

"""## Gaussian Naive Bayes Application"""

# Definicion y Construcción del Modelo
model_GNB = GaussianNB()
# Entrenar Modelo
model_GNB.fit(X_train,y_train)

# Predicciones
y_predict_GNB = model_GNB.predict(X_test)

accuracy_GNB = accuracy_score(y_test,y_predict_GNB)
print('The accuracy of GNB is {:.4f}'.format(accuracy_GNB))

confus_matrix_GNB = confusion_matrix(y_test,y_predict_GNB)
plt.title('Confusion matrix GNB')
sns.heatmap(confus_matrix_GNB, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie_GNB = pd.Series(accuracy_GNB,index=['GNB'])
accuracy_model_GNB = pd.DataFrame({'accuracy':serie_GNB})

# Extraer valores de la matriz de confusión
TN_GNB, FP_GNB, FN_GNB, TP_GNB = confus_matrix_GNB.ravel()

# Calcular métricas derivadas
accuracy_GNB = accuracy_score(y_test, y_predict_GNB)
precision_GNB = precision_score(y_test, y_predict_GNB)
recall_GNB = recall_score(y_test, y_predict_GNB)
specificity_GNB = TN_GNB / (TN_GNB + FP_GNB)
f1_GNB = f1_score(y_test, y_predict_GNB)

y_proba_GNB = model_GNB.predict_proba(X_test)[:, 1]
roc_auc_GNB = roc_auc_score(y_test, y_proba_GNB)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_GNB:.4f}")
print(f"🔹 Precision (PPV): {precision_GNB:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_GNB:.4f}")
print(f"🔹 Specificity (TNR): {specificity_GNB:.4f}")
print(f"🔹 F1-Score: {f1_GNB:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_GNB:.4f}")

"""## SVC: (RBF Kernel)"""

# Definicion y Construcción del Modelo
model_SVC = SVC()
model_SVC.fit(X_train,y_train)

# Predicciones
y_predict_SVC = model_SVC.predict(X_test)

accuracy_SVC = accuracy_score(y_test,y_predict_SVC)
print('The accuracy of SVC is {:.4f}'.format(accuracy_SVC))

confus_matrix_SVC = confusion_matrix(y_test,y_predict_SVC)
plt.title('Confusion matrix SVC')
sns.heatmap(confus_matrix_SVC, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie_SVC = pd.Series(accuracy_SVC,index=['SVC'])
accuracy_model_SVC = pd.DataFrame({'accuracy':serie_SVC})

# Extraer valores de la matriz de confusión
TN_SVC, FP_SVC, FN_SVC, TP_SVC = confus_matrix_SVC.ravel()

# Calcular métricas derivadas
accuracy_SVC = accuracy_score(y_test, y_predict_SVC)
precision_SVC = precision_score(y_test, y_predict_SVC)
recall_SVC = recall_score(y_test, y_predict_SVC)
specificity_SVC = TN_SVC / (TN_SVC + FP_SVC)
f1_SVC = f1_score(y_test, y_predict_SVC)


# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_SVC:.4f}")
print(f"🔹 Precision (PPV): {precision_SVC:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_SVC:.4f}")
print(f"🔹 Specificity (TNR): {specificity_SVC:.4f}")
print(f"🔹 F1-Score: {f1_SVC:.4f}")

"""## GradientBoostingClassifier"""

# Definicion y Construcción del Modelo
model_GBC = GradientBoostingClassifier()
model_GBC.fit(X_train,y_train)

# Predicciones o respuestas del Modelo
y_predict_GBC = model_GBC.predict(X_test)

# Generamos la Matriz de Confusión
accuracy_GBC = accuracy_score(y_test,y_predict_GBC)
print('The accuracy of GBC is {:.4f}'.format(accuracy_GBC))

confus_matrix_GBC = confusion_matrix(y_test,y_predict_GBC)
plt.title('Confusion matrix GBC')
sns.heatmap(confus_matrix_GBC, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie_GBC = pd.Series(accuracy_GBC,index=['GBC'])
accuracy_model_GBC = pd.DataFrame({'accuracy':serie_GBC})

# Extraer valores de la matriz de confusión
TN_GBC, FP_GBC, FN_GBC, TP_GBC = confus_matrix_GBC.ravel()

# Calcular métricas derivadas
accuracy_GBC = accuracy_score(y_test, y_predict_GBC)
precision_GBC = precision_score(y_test, y_predict_GBC)
recall_GBC = recall_score(y_test, y_predict_GBC)
specificity_GBC = TN_GBC / (TN_GBC + FP_GBC)
f1_GBC = f1_score(y_test, y_predict_GBC)

y_proba_GBC = model_GBC.predict_proba(X_test)[:, 1]
roc_auc_GBC = roc_auc_score(y_test, y_proba_GBC)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_GBC:.4f}")
print(f"🔹 Precision (PPV): {precision_GBC:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_GBC:.4f}")
print(f"🔹 Specificity (TNR): {specificity_GBC:.4f}")
print(f"🔹 F1-Score: {f1_GBC:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_GBC:.4f}")

"""## SGDClassifier"""

# Definicion y Construcción del Modelo
model_SGD = SGDClassifier()
model_SGD.fit(X_train,y_train)

# Predicciones o respuestas del Modelo
y_predict_SGD = model_SGD.predict(X_test)

# Generamos la Matriz de Confusión
accuracy_SGD = accuracy_score(y_test,y_predict_SGD)
print('The accuracy of SGD is {:.4f}'.format(accuracy_SGD))

confus_matrix_SGD = confusion_matrix(y_test,y_predict_SGD)
plt.title('Confusion matrix SGD')
sns.heatmap(confus_matrix_SGD, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie_SGD = pd.Series(accuracy_SGD,index=['SGD'])
accuracy_model_SGD = pd.DataFrame({'accuracy':serie_SGD})

TN_SGD, FP_SGD, FN_SGD, TP_SGD = confus_matrix_SGD.ravel()

# Calcular métricas derivadas
accuracy_SGD = accuracy_score(y_test, y_predict_SGD)
precision_SGD = precision_score(y_test, y_predict_SGD)
recall_SGD = recall_score(y_test, y_predict_SGD)
specificity_SGD = TN_SGD / (TN_SGD + FP_SGD)
f1_SGD = f1_score(y_test, y_predict_SGD)



# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_SGD:.4f}")
print(f"🔹 Precision (PPV): {precision_SGD:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_SGD:.4f}")
print(f"🔹 Specificity (TNR): {specificity_SGD:.4f}")
print(f"🔹 F1-Score: {f1_SGD:.4f}")

"""## ExtraTreesClassifier"""

# Definicion y Construcción del Modelo
model_EXTRATC = ExtraTreesClassifier()
# Entrenar Modelo
model_EXTRATC.fit(X_train,y_train)

# Predicciones
y_predict_EXTRATC = model_EXTRATC.predict(X_test)

accuracy_EXTRATC = accuracy_score(y_test,y_predict_EXTRATC)
print('The accuracy of EXTRATC is {:.4f}'.format(accuracy_EXTRATC))

confus_matrix_EXTRATC = confusion_matrix(y_test,y_predict_EXTRATC)
plt.title('Confusion matrix EXTRATC')
sns.heatmap(confus_matrix_EXTRATC, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie_EXTRATC = pd.Series(accuracy_EXTRATC,index=['EXTRATC'])
accuracy_model_EXTRATC = pd.DataFrame({'accuracy':serie_EXTRATC})

TN, FP, FN, TP = confus_matrix.ravel()
print(TN, FP, FN, TP)

# Calcular métricas derivadas
accuracy_EXTRATC = accuracy_score(y_test, y_predict_EXTRATC)
precision_EXTRATC = precision_score(y_test, y_predict_EXTRATC)
recall_EXTRATC = recall_score(y_test, y_predict_EXTRATC)
specificity_EXTRATC = TN / (TN + FP)
f1_EXTRATC = f1_score(y_test, y_predict_EXTRATC)

y_proba = model_EXTRATC.predict_proba(X_test)[:, 1]
roc_auc_EXTRATC = roc_auc_score(y_test, y_proba)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_EXTRATC:.4f}")
print(f"🔹 Precision (PPV): {precision_EXTRATC:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_EXTRATC:.4f}")
print(f"🔹 Specificity (TNR): {specificity_EXTRATC:.4f}")
print(f"🔹 F1-Score: {f1_EXTRATC:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_EXTRATC:.4f}")

"""# **Categoría con  Balanceo Smote**"""

# Balanceo con Smote
smote  = SMOTE(sampling_strategy='auto', random_state=42)
X_smote, y_smote = smote.fit_resample(X, y) #Ingreso los X & y Originales

# Construimos la nueva versión del Dataset balanceado con Smote
data_smote = pd.DataFrame(X_smote, columns=X.columns)
data_smote["Target"] = y_smote # Agregar la variable objetivo balanceada reemplazando la anterior
data_smote

#División de Datos
X_smote = data_smote.drop(['Target'],axis=1) # Eliminamos la variable objetivo para obtener solo las v. independiente (x)
y_smote = data_smote['Target']
X_train_smote, X_test_smote, y_train_smote, y_test_smote = train_test_split(X_smote,y_smote,train_size=0.7)

"""## Regresion Logistica"""

# Definir y entrenar el modelo
model_smote_LR = LogisticRegression()
model_smote_LR.fit(X_train_smote,y_train_smote)

#Predicciones
y_predict_smote_LR = model_smote_LR.predict(X_test_smote)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote,y_predict_smote_LR)
print('The accuracy of Logistic Regression is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote,y_predict_smote_LR)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['LogisticRegression'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_LR, FP_smote_LR, FN_smote_LR, TP_smote_LR = confus_matrix.ravel()
print(TN_smote_LR, FP_smote_LR, FN_smote_LR, TP_smote_LR)

# Calcular métricas derivadas
accuracy_smote_LR = accuracy_score(y_test_smote, y_predict_smote_LR)
precision_smote_LR = precision_score(y_test_smote, y_predict_smote_LR)
recall_smote_LR = recall_score(y_test_smote, y_predict_smote_LR)
specificity_smote_LR = TN / (TN + FP)
f1_smote_LR = f1_score(y_test_smote, y_predict_smote_LR)

y_proba_smote_LR = model_smote_LR.predict_proba(X_test_smote)[:, 1]
roc_auc_smote_LR = roc_auc_score(y_test_smote, y_proba_smote_LR)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_LR:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_LR:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_LR:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_LR:.4f}")
print(f"🔹 F1-Score: {f1_smote_LR:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_LR:.4f}")

"""## HistGradientBoosting"""

# Definir y entrenar el modelo
model_smote_HGBoost = HistGradientBoostingClassifier()
model_smote_HGBoost.fit(X_train_smote,y_train_smote)

#Predicciones
y_predict_smote_HGBoost = model_smote_HGBoost.predict(X_test_smote)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote,y_predict_smote_HGBoost)
print('The accuracy of HistGradientBoostingClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote,y_predict_smote_HGBoost)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['HistGradientBoostingClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_HGBoost, FP_smote_HGBoost, FN_smote_HGBoost, TP_smote_HGBoost = confus_matrix.ravel()
print(TN_smote_HGBoost, FP_smote_HGBoost, FN_smote_HGBoost, TP_smote_HGBoost)

# Calcular métricas derivadas
accuracy_smote_HGBoost = accuracy_score(y_test_smote, y_predict_smote_HGBoost)
precision_smote_HGBoost = precision_score(y_test_smote, y_predict_smote_HGBoost)
recall_smote_HGBoost = recall_score(y_test_smote, y_predict_smote_HGBoost)
specificity_smote_HGBoost = TN / (TN + FP)
f1_smote_HGBoost = f1_score(y_test_smote, y_predict_smote_HGBoost)

y_proba_smote_HGBoost = model_smote_HGBoost.predict_proba(X_test_smote)[:, 1]
roc_auc_smote_HGBoost = roc_auc_score(y_test_smote, y_proba_smote_HGBoost)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_HGBoost:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_HGBoost:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_HGBoost:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_HGBoost:.4f}")
print(f"🔹 F1-Score: {f1_smote_HGBoost:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_HGBoost:.4f}")

"""## KNeighbors KNN"""

# Definir y entrenar el modelo
model_smote_KNN = KNeighborsClassifier()
model_smote_KNN.fit(X_train_smote,y_train_smote)

#Predicciones
y_predict_smote_KNN = model_smote_KNN.predict(X_test_smote)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote,y_predict_smote_KNN)
print('The accuracy of KNeighborsClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote,y_predict_smote_KNN)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['KNeighborsClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_KNN, FP_smote_KNN, FN_smote_KNN, TP_smote_KNN = confus_matrix.ravel()
print(TN_smote_KNN, FP_smote_KNN, FN_smote_KNN, TP_smote_KNN)

# Calcular métricas derivadas
accuracy_smote_KNN = accuracy_score(y_test_smote, y_predict_smote_KNN)
precision_smote_KNN = precision_score(y_test_smote, y_predict_smote_KNN)
recall_smote_KNN = recall_score(y_test_smote, y_predict_smote_KNN)
specificity_smote_KNN = TN / (TN + FP)
f1_smote_KNN = f1_score(y_test_smote, y_predict_smote_KNN)

y_proba_smote_KNN = model_smote_KNN.predict_proba(X_test_smote)[:, 1]
roc_auc_smote_KNN = roc_auc_score(y_test_smote, y_proba_smote_KNN)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_KNN:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_KNN:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_KNN:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_KNN:.4f}")
print(f"🔹 F1-Score: {f1_smote_KNN:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_KNN:.4f}")

"""## Decision tree Application"""

# Definir y entrenar el modelo
model_smote_DT= DecisionTreeClassifier ()
model_smote_DT.fit(X_train_smote,y_train_smote)

#Predicciones
y_predict_smote_DT = model_smote_DT.predict(X_test_smote)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote,y_predict_smote_DT)
print('The accuracy of DecisionTreeClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote,y_predict_smote_DT)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['DecisionTreeClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_DT, FP_smote_DT, FN_smote_DT, TP_smote_DT = confus_matrix.ravel()
print(TN_smote_DT, FP_smote_DT, FN_smote_DT, TP_smote_DT)

# Calcular métricas derivadas
accuracy_smote_DT = accuracy_score(y_test_smote, y_predict_smote_DT)
precision_smote_DT = precision_score(y_test_smote, y_predict_smote_DT)
recall_smote_DT = recall_score(y_test_smote, y_predict_smote_DT)
specificity_smote_DT = TN / (TN + FP)
f1_smote_DT = f1_score(y_test_smote, y_predict_smote_DT)

y_proba_smote_DT = model_smote_DT.predict_proba(X_test_smote)[:, 1]
roc_auc_smote_DT = roc_auc_score(y_test_smote, y_proba_smote_DT)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_DT:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_DT:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_DT:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_DT:.4f}")
print(f"🔹 F1-Score: {f1_smote_DT:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_DT:.4f}")

"""## Random Forest"""

# Definir y entrenar el modelo
model_smote_RF= RandomForestClassifier ()
model_smote_RF.fit(X_train_smote,y_train_smote)

#Predicciones
y_predict_smote_RF = model_smote_RF.predict(X_test_smote)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote,y_predict_smote_RF)
print('The accuracy of RandomForestClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote,y_predict_smote_RF)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['RandomForestClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_RF, FP_smote_RF, FN_smote_RF, TP_smote_RF = confus_matrix.ravel()
print(TN_smote_RF, FP_smote_RF, FN_smote_RF, TP_smote_RF)

# Calcular métricas derivadas
accuracy_smote_RF = accuracy_score(y_test_smote, y_predict_smote_RF)
precision_smote_RF = precision_score(y_test_smote, y_predict_smote_RF)
recall_smote_RF = recall_score(y_test_smote, y_predict_smote_RF)
specificity_smote_RF = TN / (TN + FP)
f1_smote_RF = f1_score(y_test_smote, y_predict_smote_RF)

y_proba_smote_RF = model_smote_RF.predict_proba(X_test_smote)[:, 1]
roc_auc_smote_RF = roc_auc_score(y_test_smote, y_proba_smote_RF)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_RF:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_RF:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_RF:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_RF:.4f}")
print(f"🔹 F1-Score: {f1_smote_RF:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_RF:.4f}")

"""## Gaussian Naive Bayes Application"""

# Definir y entrenar el modelo
model_smote_GNB = GaussianNB()
model_smote_GNB.fit(X_train_smote,y_train_smote)

#Predicciones
y_predict_smote_GNB = model_smote_GNB.predict(X_test_smote)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote,y_predict_smote_GNB)
print('The accuracy of Logistic Regression is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote,y_predict_smote_GNB)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['LogisticRegression'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_GNB, FP_smote_GNB, FN_smote_GNB, TP_smote_GNB = confus_matrix.ravel()
print(TN_smote_GNB, FP_smote_GNB, FN_smote_GNB, TP_smote_GNB)

# Calcular métricas derivadas
accuracy_smote_GNB = accuracy_score(y_test_smote, y_predict_smote_GNB)
precision_smote_GNB = precision_score(y_test_smote, y_predict_smote_GNB)
recall_smote_GNB = recall_score(y_test_smote, y_predict_smote_GNB)
specificity_smote_GNB = TN / (TN + FP)
f1_smote_GNB = f1_score(y_test_smote, y_predict_smote_GNB)

y_proba_smote_GNB = model_smote_GNB.predict_proba(X_test_smote)[:, 1]
roc_auc_smote_GNB = roc_auc_score(y_test_smote, y_proba_smote_GNB)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_GNB:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_GNB:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_GNB:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_GNB:.4f}")
print(f"🔹 F1-Score: {f1_smote_GNB:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_GNB:.4f}")

"""## SVC: (RBF Kernel)"""

# Definir y entrenar el modelo
model_smote_SVC = SVC()
model_smote_SVC.fit(X_train_smote,y_train_smote)

#Predicciones
y_predict_smote_SVC = model_smote_SVC.predict(X_test_smote)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote,y_predict_smote_SVC)
print('The accuracy of SVC is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote,y_predict_smote_SVC)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['SVC'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_SVC, FP_smote_SVC, FN_smote_SVC, TP_smote_SVC = confus_matrix.ravel()
print(TN_smote_SVC, FP_smote_SVC, FN_smote_SVC, TP_smote_SVC)

# Calcular métricas derivadas
accuracy_smote_SVC = accuracy_score(y_test_smote, y_predict_smote_SVC)
precision_smote_SVC = precision_score(y_test_smote, y_predict_smote_SVC)
recall_smote_SVC = recall_score(y_test_smote, y_predict_smote_SVC)
specificity_smote_SVC = TN / (TN + FP)
f1_smote_SVC = f1_score(y_test_smote, y_predict_smote_SVC)



# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_SVC:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_SVC:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_SVC:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_SVC:.4f}")
print(f"🔹 F1-Score: {f1_smote_SVC:.4f}")

"""## GradientBoostingClassifier"""

# Definir y entrenar el modelo
model_smote_GBC = GradientBoostingClassifier()
model_smote_GBC.fit(X_train_smote,y_train_smote)

#Predicciones
y_predict_smote_GBC = model_smote_GBC.predict(X_test_smote)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote,y_predict_smote_GBC)
print('The accuracy of GradientBoostingClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote,y_predict_smote_GBC)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['GradientBoostingClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_GBC, FP_smote_GBC, FN_smote_GBC, TP_smote_GBC = confus_matrix.ravel()
print(TN_smote_GBC, FP_smote_GBC, FN_smote_GBC, TP_smote_GBC)

# Calcular métricas derivadas
accuracy_smote_GBC = accuracy_score(y_test_smote, y_predict_smote_GBC)
precision_smote_GBC = precision_score(y_test_smote, y_predict_smote_GBC)
recall_smote_GBC = recall_score(y_test_smote, y_predict_smote_GBC)
specificity_smote_GBC = TN / (TN + FP)
f1_smote_GBC = f1_score(y_test_smote, y_predict_smote_GBC)

y_proba_smote_GBC = model_smote_GBC.predict_proba(X_test_smote)[:, 1]
roc_auc_smote_GBC = roc_auc_score(y_test_smote, y_proba_smote_GBC)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_GBC:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_GBC:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_GBC:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_GBC:.4f}")
print(f"🔹 F1-Score: {f1_smote_GBC:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_GBC:.4f}")

"""## SGDClassifier"""

# Definir y entrenar el modelo
model_smote_SGD = SGDClassifier()
model_smote_SGD.fit(X_train_smote,y_train_smote)

#Predicciones
y_predict_smote_SGD = model_smote_SGD.predict(X_test_smote)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote,y_predict_smote_SGD)
print('The accuracy of SGDClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote,y_predict_smote_SGD)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['SGDClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_SGD, FP_smote_SGD, FN_smote_SGD, TP_smote_SGD = confus_matrix.ravel()
print(TN_smote_SGD, FP_smote_SGD, FN_smote_SGD, TP_smote_SGD)

# Calcular métricas derivadas
accuracy_smote_SGD = accuracy_score(y_test_smote, y_predict_smote_SGD)
precision_smote_SGD = precision_score(y_test_smote, y_predict_smote_SGD)
recall_smote_SGD = recall_score(y_test_smote, y_predict_smote_SGD)
specificity_smote_SGD = TN / (TN + FP)
f1_smote_SGD = f1_score(y_test_smote, y_predict_smote_SGD)




# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_SGD:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_SGD:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_SGD:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_SGD:.4f}")
print(f"🔹 F1-Score: {f1_smote_SGD:.4f}")

"""## ExtraTreesClassifier"""

# Definir y entrenar el modelo
model_smote_EXTRATC = ExtraTreesClassifier()
model_smote_EXTRATC.fit(X_train_smote,y_train_smote)

#Predicciones
y_predict_smote_EXTRATC = model_smote_EXTRATC.predict(X_test_smote)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote,y_predict_smote_EXTRATC)
print('The accuracy of EXTRATCClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote,y_predict_smote_EXTRATC)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['EXTRATCClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_EXTRATC, FP_smote_EXTRATC, FN_smote_EXTRATC, TP_smote_EXTRATC = confus_matrix.ravel()
print(TN_smote_EXTRATC, FP_smote_EXTRATC, FN_smote_EXTRATC, TP_smote_EXTRATC)

# Calcular métricas derivadas
accuracy_smote_EXTRATC = accuracy_score(y_test_smote, y_predict_smote_EXTRATC)
precision_smote_EXTRATC = precision_score(y_test_smote, y_predict_smote_EXTRATC)
recall_smote_EXTRATC = recall_score(y_test_smote, y_predict_smote_EXTRATC)
specificity_smote_EXTRATC = TN / (TN + FP)
f1_smote_EXTRATC = f1_score(y_test_smote, y_predict_smote_EXTRATC)

y_proba_smote_EXTRATC = model_smote_EXTRATC.predict_proba(X_test_smote)[:, 1]
roc_auc_smote_EXTRATC = roc_auc_score(y_test_smote, y_proba_smote_EXTRATC)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_EXTRATC:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_EXTRATC:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_EXTRATC:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_EXTRATC:.4f}")
print(f"🔹 F1-Score: {f1_smote_EXTRATC:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_EXTRATC:.4f}")

"""# **Categoría con  Balanceo RUS**"""

# Balanceo con rus
rus = RandomUnderSampler(sampling_strategy='auto', random_state=42)
X_rus, y_rus = rus.fit_resample(X, y) #Ingreso los X & y Originales

# Construimos la nueva versión del Dataset balanceado con rus
data_rus = pd.DataFrame(X_rus, columns=X.columns)
data_rus["Target"] = y_rus # Agregar la variable objetivo balanceada reemplazando la anterior
data_rus

#División de Datos
X_rus = data_rus.drop(['Target'],axis=1) # Eliminamos la variable objetivo para obtener solo las v. independiente (x)
y_rus = data_rus['Target']
X_train_rus, X_test_rus, y_train_rus, y_test_rus = train_test_split(X_rus,y_rus,train_size=0.7)

"""## Regresion Logistica"""

# Definir y entrenar el modelo
model_rus_LR = LogisticRegression()
model_rus_LR.fit(X_train_rus,y_train_rus)

#Predicciones
y_predict_rus_LR = model_rus_LR.predict(X_test_rus)

#Matriz de confusión
accuracy = accuracy_score(y_test_rus,y_predict_rus_LR)
print('The accuracy of Logistic Regression is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_rus,y_predict_rus_LR)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['LogisticRegression'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_rus_LR, FP_rus_LR, FN_rus_LR, TP_rus_LR = confus_matrix.ravel()
print(TN_rus_LR, FP_rus_LR, FN_rus_LR, TP_rus_LR)

# Calcular métricas derivadas
accuracy_rus_LR = accuracy_score(y_test_rus, y_predict_rus_LR)
precision_rus_LR = precision_score(y_test_rus, y_predict_rus_LR)
recall_rus_LR = recall_score(y_test_rus, y_predict_rus_LR)
specificity_rus_LR = TN / (TN + FP)
f1_rus_LR = f1_score(y_test_rus, y_predict_rus_LR)

y_proba_rus_LR = model_rus_LR.predict_proba(X_test_rus)[:, 1]
roc_auc_rus_LR = roc_auc_score(y_test_rus, y_proba_rus_LR)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_rus_LR:.4f}")
print(f"🔹 Precision (PPV): {precision_rus_LR:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_rus_LR:.4f}")
print(f"🔹 Specificity (TNR): {specificity_rus_LR:.4f}")
print(f"🔹 F1-Score: {f1_rus_LR:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_rus_LR:.4f}")

"""## HistGradientBoosting"""

# Definir y entrenar el modelo
model_rus_HGBoost = HistGradientBoostingClassifier()
model_rus_HGBoost.fit(X_train_rus,y_train_rus)

#Predicciones
y_predict_rus_HGBoost = model_rus_HGBoost.predict(X_test_rus)

#Matriz de confusión
accuracy = accuracy_score(y_test_rus,y_predict_rus_HGBoost)
print('The accuracy of HistGradientBoostingClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_rus,y_predict_rus_HGBoost)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['HistGradientBoostingClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_rus_HGBoost, FP_rus_HGBoost, FN_rus_HGBoost, TP_rus_HGBoost = confus_matrix.ravel()
print(TN_rus_HGBoost, FP_rus_HGBoost, FN_rus_HGBoost, TP_rus_HGBoost)

# Calcular métricas derivadas
accuracy_rus_HGBoost = accuracy_score(y_test_rus, y_predict_rus_HGBoost)
precision_rus_HGBoost = precision_score(y_test_rus, y_predict_rus_HGBoost)
recall_rus_HGBoost = recall_score(y_test_rus, y_predict_rus_HGBoost)
specificity_rus_HGBoost = TN / (TN + FP)
f1_rus_HGBoost = f1_score(y_test_rus, y_predict_rus_HGBoost)

y_proba_rus_HGBoost = model_rus_HGBoost.predict_proba(X_test_rus)[:, 1]
roc_auc_rus_HGBoost = roc_auc_score(y_test_rus, y_proba_rus_HGBoost)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_rus_HGBoost:.4f}")
print(f"🔹 Precision (PPV): {precision_rus_HGBoost:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_rus_HGBoost:.4f}")
print(f"🔹 Specificity (TNR): {specificity_rus_HGBoost:.4f}")
print(f"🔹 F1-Score: {f1_rus_HGBoost:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_rus_HGBoost:.4f}")

"""## KNeighbors KNN"""

# Definir y entrenar el modelo
model_rus_KNN = KNeighborsClassifier()
model_rus_KNN.fit(X_train_rus,y_train_rus)

#Predicciones
y_predict_rus_KNN = model_rus_KNN.predict(X_test_rus)

#Matriz de confusión
accuracy = accuracy_score(y_test_rus,y_predict_rus_KNN)
print('The accuracy of KNeighborsClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_rus,y_predict_rus_KNN)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['KNeighborsClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_rus_KNN, FP_rus_KNN, FN_rus_KNN, TP_rus_KNN = confus_matrix.ravel()
print(TN_rus_KNN, FP_rus_KNN, FN_rus_KNN, TP_rus_KNN)

# Calcular métricas derivadas
accuracy_rus_KNN = accuracy_score(y_test_rus, y_predict_rus_KNN)
precision_rus_KNN = precision_score(y_test_rus, y_predict_rus_KNN)
recall_rus_KNN = recall_score(y_test_rus, y_predict_rus_KNN)
specificity_rus_KNN = TN / (TN + FP)
f1_rus_KNN = f1_score(y_test_rus, y_predict_rus_KNN)

y_proba_rus_KNN = model_rus_KNN.predict_proba(X_test_rus)[:, 1]
roc_auc_rus_KNN = roc_auc_score(y_test_rus, y_proba_rus_KNN)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_rus_KNN:.4f}")
print(f"🔹 Precision (PPV): {precision_rus_KNN:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_rus_KNN:.4f}")
print(f"🔹 Specificity (TNR): {specificity_rus_KNN:.4f}")
print(f"🔹 F1-Score: {f1_rus_KNN:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_rus_KNN:.4f}")

"""## Decision tree Application"""

# Definir y entrenar el modelo
model_rus_DT= DecisionTreeClassifier ()
model_rus_DT.fit(X_train_rus,y_train_rus)

#Predicciones
y_predict_rus_DT = model_rus_DT.predict(X_test_rus)

#Matriz de confusión
accuracy = accuracy_score(y_test_rus,y_predict_rus_DT)
print('The accuracy of DecisionTreeClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_rus,y_predict_rus_DT)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['DecisionTreeClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_rus_DT, FP_rus_DT, FN_rus_DT, TP_rus_DT = confus_matrix.ravel()
print(TN_rus_DT, FP_rus_DT, FN_rus_DT, TP_rus_DT)

# Calcular métricas derivadas
accuracy_rus_DT = accuracy_score(y_test_rus, y_predict_rus_DT)
precision_rus_DT = precision_score(y_test_rus, y_predict_rus_DT)
recall_rus_DT = recall_score(y_test_rus, y_predict_rus_DT)
specificity_rus_DT = TN / (TN + FP)
f1_rus_DT = f1_score(y_test_rus, y_predict_rus_DT)

y_proba_rus_DT = model_rus_DT.predict_proba(X_test_rus)[:, 1]
roc_auc_rus_DT = roc_auc_score(y_test_rus, y_proba_rus_DT)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_rus_DT:.4f}")
print(f"🔹 Precision (PPV): {precision_rus_DT:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_rus_DT:.4f}")
print(f"🔹 Specificity (TNR): {specificity_rus_DT:.4f}")
print(f"🔹 F1-Score: {f1_rus_DT:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_rus_DT:.4f}")

"""## Random Forest"""

# Definir y entrenar el modelo
model_rus_RF= RandomForestClassifier ()
model_rus_RF.fit(X_train_rus,y_train_rus)

#Predicciones
y_predict_rus_RF = model_rus_RF.predict(X_test_rus)

#Matriz de confusión
accuracy = accuracy_score(y_test_rus,y_predict_rus_RF)
print('The accuracy of RandomForestClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_rus,y_predict_rus_RF)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['RandomForestClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_rus_RF, FP_rus_RF, FN_rus_RF, TP_rus_RF = confus_matrix.ravel()
print(TN_rus_RF, FP_rus_RF, FN_rus_RF, TP_rus_RF)

# Calcular métricas derivadas
accuracy_rus_RF = accuracy_score(y_test_rus, y_predict_rus_RF)
precision_rus_RF = precision_score(y_test_rus, y_predict_rus_RF)
recall_rus_RF = recall_score(y_test_rus, y_predict_rus_RF)
specificity_rus_RF = TN / (TN + FP)
f1_rus_RF = f1_score(y_test_rus, y_predict_rus_RF)

y_proba_rus_RF = model_rus_RF.predict_proba(X_test_rus)[:, 1]
roc_auc_rus_RF = roc_auc_score(y_test_rus, y_proba_rus_RF)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_rus_RF:.4f}")
print(f"🔹 Precision (PPV): {precision_rus_RF:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_rus_RF:.4f}")
print(f"🔹 Specificity (TNR): {specificity_rus_RF:.4f}")
print(f"🔹 F1-Score: {f1_rus_RF:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_rus_RF:.4f}")

"""## Gaussian Naive Bayes Application"""

# Definir y entrenar el modelo
model_rus_GNB = GaussianNB()
model_rus_GNB.fit(X_train_rus,y_train_rus)

#Predicciones
y_predict_rus_GNB = model_rus_GNB.predict(X_test_rus)

#Matriz de confusión
accuracy = accuracy_score(y_test_rus,y_predict_rus_GNB)
print('The accuracy of Logistic Regression is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_rus,y_predict_rus_GNB)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['LogisticRegression'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_rus_GNB, FP_rus_GNB, FN_rus_GNB, TP_rus_GNB = confus_matrix.ravel()
print(TN_rus_GNB, FP_rus_GNB, FN_rus_GNB, TP_rus_GNB)

# Calcular métricas derivadas
accuracy_rus_GNB = accuracy_score(y_test_rus, y_predict_rus_GNB)
precision_rus_GNB = precision_score(y_test_rus, y_predict_rus_GNB)
recall_rus_GNB = recall_score(y_test_rus, y_predict_rus_GNB)
specificity_rus_GNB = TN / (TN + FP)
f1_rus_GNB = f1_score(y_test_rus, y_predict_rus_GNB)

y_proba_rus_GNB = model_rus_GNB.predict_proba(X_test_rus)[:, 1]
roc_auc_rus_GNB = roc_auc_score(y_test_rus, y_proba_rus_GNB)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_rus_GNB:.4f}")
print(f"🔹 Precision (PPV): {precision_rus_GNB:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_rus_GNB:.4f}")
print(f"🔹 Specificity (TNR): {specificity_rus_GNB:.4f}")
print(f"🔹 F1-Score: {f1_rus_GNB:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_rus_GNB:.4f}")

"""## SVC: (RBF Kernel)"""

# Definir y entrenar el modelo
model_rus_SVC = SVC()
model_rus_SVC.fit(X_train_rus,y_train_rus)

#Predicciones
y_predict_rus_SVC = model_rus_SVC.predict(X_test_rus)

#Matriz de confusión
accuracy = accuracy_score(y_test_rus,y_predict_rus_SVC)
print('The accuracy of SVC is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_rus,y_predict_rus_SVC)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['SVC'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_rus_SVC, FP_rus_SVC, FN_rus_SVC, TP_rus_SVC = confus_matrix.ravel()
print(TN_rus_SVC, FP_rus_SVC, FN_rus_SVC, TP_rus_SVC)

# Calcular métricas derivadas
accuracy_rus_SVC = accuracy_score(y_test_rus, y_predict_rus_SVC)
precision_rus_SVC = precision_score(y_test_rus, y_predict_rus_SVC)
recall_rus_SVC = recall_score(y_test_rus, y_predict_rus_SVC)
specificity_rus_SVC = TN / (TN + FP)
f1_rus_SVC = f1_score(y_test_rus, y_predict_rus_SVC)



# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_rus_SVC:.4f}")
print(f"🔹 Precision (PPV): {precision_rus_SVC:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_rus_SVC:.4f}")
print(f"🔹 Specificity (TNR): {specificity_rus_SVC:.4f}")
print(f"🔹 F1-Score: {f1_rus_SVC:.4f}")

"""## GradientBoostingClassifier"""

# Definir y entrenar el modelo
model_rus_GBC = GradientBoostingClassifier()
model_rus_GBC.fit(X_train_rus,y_train_rus)

#Predicciones
y_predict_rus_GBC = model_rus_GBC.predict(X_test_rus)

#Matriz de confusión
accuracy = accuracy_score(y_test_rus,y_predict_rus_GBC)
print('The accuracy of GradientBoostingClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_rus,y_predict_rus_GBC)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['GradientBoostingClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_rus_GBC, FP_rus_GBC, FN_rus_GBC, TP_rus_GBC = confus_matrix.ravel()
print(TN_rus_GBC, FP_rus_GBC, FN_rus_GBC, TP_rus_GBC)

# Calcular métricas derivadas
accuracy_rus_GBC = accuracy_score(y_test_rus, y_predict_rus_GBC)
precision_rus_GBC = precision_score(y_test_rus, y_predict_rus_GBC)
recall_rus_GBC = recall_score(y_test_rus, y_predict_rus_GBC)
specificity_rus_GBC = TN / (TN + FP)
f1_rus_GBC = f1_score(y_test_rus, y_predict_rus_GBC)

y_proba_rus_GBC = model_rus_GBC.predict_proba(X_test_rus)[:, 1]
roc_auc_rus_GBC = roc_auc_score(y_test_rus, y_proba_rus_GBC)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_rus_GBC:.4f}")
print(f"🔹 Precision (PPV): {precision_rus_GBC:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_rus_GBC:.4f}")
print(f"🔹 Specificity (TNR): {specificity_rus_GBC:.4f}")
print(f"🔹 F1-Score: {f1_rus_GBC:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_rus_GBC:.4f}")

"""## SGDClassifier"""

# Definir y entrenar el modelo
model_rus_SGD = SGDClassifier()
model_rus_SGD.fit(X_train_rus,y_train_rus)

#Predicciones
y_predict_rus_SGD = model_rus_SGD.predict(X_test_rus)

#Matriz de confusión
accuracy = accuracy_score(y_test_rus,y_predict_rus_SGD)
print('The accuracy of SGDClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_rus,y_predict_rus_SGD)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['SGDClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_rus_SGD, FP_rus_SGD, FN_rus_SGD, TP_rus_SGD = confus_matrix.ravel()
print(TN_rus_SGD, FP_rus_SGD, FN_rus_SGD, TP_rus_SGD)

# Calcular métricas derivadas
accuracy_rus_SGD = accuracy_score(y_test_rus, y_predict_rus_SGD)
precision_rus_SGD = precision_score(y_test_rus, y_predict_rus_SGD)
recall_rus_SGD = recall_score(y_test_rus, y_predict_rus_SGD)
specificity_rus_SGD = TN / (TN + FP)
f1_rus_SGD = f1_score(y_test_rus, y_predict_rus_SGD)




# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_rus_SGD:.4f}")
print(f"🔹 Precision (PPV): {precision_rus_SGD:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_rus_SGD:.4f}")
print(f"🔹 Specificity (TNR): {specificity_rus_SGD:.4f}")
print(f"🔹 F1-Score: {f1_rus_SGD:.4f}")

"""## ExtraTreesClassifier"""

# Definir y entrenar el modelo
model_rus_EXTRATC = ExtraTreesClassifier()
model_rus_EXTRATC.fit(X_train_rus,y_train_rus)

#Predicciones
y_predict_rus_EXTRATC = model_rus_EXTRATC.predict(X_test_rus)

#Matriz de confusión
accuracy = accuracy_score(y_test_rus,y_predict_rus_EXTRATC)
print('The accuracy of EXTRATCClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_rus,y_predict_rus_EXTRATC)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['EXTRATCClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_rus_EXTRATC, FP_rus_EXTRATC, FN_rus_EXTRATC, TP_rus_EXTRATC = confus_matrix.ravel()
print(TN_rus_EXTRATC, FP_rus_EXTRATC, FN_rus_EXTRATC, TP_rus_EXTRATC)

# Calcular métricas derivadas
accuracy_rus_EXTRATC = accuracy_score(y_test_rus, y_predict_rus_EXTRATC)
precision_rus_EXTRATC = precision_score(y_test_rus, y_predict_rus_EXTRATC)
recall_rus_EXTRATC = recall_score(y_test_rus, y_predict_rus_EXTRATC)
specificity_rus_EXTRATC = TN / (TN + FP)
f1_rus_EXTRATC = f1_score(y_test_rus, y_predict_rus_EXTRATC)

y_proba_rus_EXTRATC = model_rus_EXTRATC.predict_proba(X_test_rus)[:, 1]
roc_auc_rus_EXTRATC = roc_auc_score(y_test_rus, y_proba_rus_EXTRATC)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_rus_EXTRATC:.4f}")
print(f"🔹 Precision (PPV): {precision_rus_EXTRATC:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_rus_EXTRATC:.4f}")
print(f"🔹 Specificity (TNR): {specificity_rus_EXTRATC:.4f}")
print(f"🔹 F1-Score: {f1_rus_EXTRATC:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_rus_EXTRATC:.4f}")

"""# **Categoría con  Balanceo Smote_Tomek**"""

# Balanceo con Smote
smote_tomek = SMOTETomek(random_state=42)
X_smote_tomek, y_smote = smote_tomek.fit_resample(X, y) #Ingreso los X & y Originales

# Construimos la nueva versión del Dataset balanceado con Smote
data_smote_tomek = pd.DataFrame(X_smote_tomek, columns=X.columns)
data_smote_tomek["Target"] = y_smote # Agregar la variable objetivo balanceada reemplazando la anterior
data_smote_tomek

#División de Datos
X_smote_tomek = data_smote_tomek.drop(['Target'],axis=1) # Eliminamos la variable objetivo para obtener solo las v. independiente (x)
y_smote_tomek = data_smote_tomek['Target']
X_train_smote_tomek, X_test_smote_tomek, y_train_smote_tomek, y_test_smote_tomek = train_test_split(X_smote_tomek,y_smote_tomek,train_size=0.7)

"""## Regresion Logistica"""

# Definir y entrenar el modelo
model_smote_tomek_LR = LogisticRegression()
model_smote_tomek_LR.fit(X_train_smote_tomek,y_train_smote_tomek)

#Predicciones
y_predict_smote_tomek_LR = model_smote_tomek_LR.predict(X_test_smote_tomek)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote_tomek,y_predict_smote_tomek_LR)
print('The accuracy of Logistic Regression is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote_tomek,y_predict_smote_tomek_LR)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['LogisticRegression'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_tomek_LR, FP_smote_tomek_LR, FN_smote_tomek_LR, TP_smote_tomek_LR = confus_matrix.ravel()
print(TN_smote_tomek_LR, FP_smote_tomek_LR, FN_smote_tomek_LR, TP_smote_tomek_LR)

# Calcular métricas derivadas
accuracy_smote_tomek_LR = accuracy_score(y_test_smote_tomek, y_predict_smote_tomek_LR)
precision_smote_tomek_LR = precision_score(y_test_smote_tomek, y_predict_smote_tomek_LR)
recall_smote_tomek_LR = recall_score(y_test_smote_tomek, y_predict_smote_tomek_LR)
specificity_smote_tomek_LR = TN / (TN + FP)
f1_smote_tomek_LR = f1_score(y_test_smote_tomek, y_predict_smote_tomek_LR)

y_proba_smote_tomek_LR = model_smote_tomek_LR.predict_proba(X_test_smote_tomek)[:, 1]
roc_auc_smote_tomek_LR = roc_auc_score(y_test_smote_tomek, y_proba_smote_tomek_LR)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_tomek_LR:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_tomek_LR:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_tomek_LR:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_tomek_LR:.4f}")
print(f"🔹 F1-Score: {f1_smote_tomek_LR:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_tomek_LR:.4f}")

"""## HistGradientBoosting"""

# Definir y entrenar el modelo
model_smote_tomek_HGBoost = HistGradientBoostingClassifier()
model_smote_tomek_HGBoost.fit(X_train_smote_tomek,y_train_smote_tomek)

#Predicciones
y_predict_smote_tomek_HGBoost = model_smote_tomek_HGBoost.predict(X_test_smote_tomek)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote_tomek,y_predict_smote_tomek_HGBoost)
print('The accuracy of HistGradientBoostingClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote_tomek,y_predict_smote_tomek_HGBoost)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['HistGradientBoostingClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_tomek_HGBoost, FP_smote_tomek_HGBoost, FN_smote_tomek_HGBoost, TP_smote_tomek_HGBoost = confus_matrix.ravel()
print(TN_smote_tomek_HGBoost, FP_smote_tomek_HGBoost, FN_smote_tomek_HGBoost, TP_smote_tomek_HGBoost)

# Calcular métricas derivadas
accuracy_smote_tomek_HGBoost = accuracy_score(y_test_smote_tomek, y_predict_smote_tomek_HGBoost)
precision_smote_tomek_HGBoost = precision_score(y_test_smote_tomek, y_predict_smote_tomek_HGBoost)
recall_smote_tomek_HGBoost = recall_score(y_test_smote_tomek, y_predict_smote_tomek_HGBoost)
specificity_smote_tomek_HGBoost = TN / (TN + FP)
f1_smote_tomek_HGBoost = f1_score(y_test_smote_tomek, y_predict_smote_tomek_HGBoost)

y_proba_smote_tomek_HGBoost = model_smote_tomek_HGBoost.predict_proba(X_test_smote_tomek)[:, 1]
roc_auc_smote_tomek_HGBoost = roc_auc_score(y_test_smote_tomek, y_proba_smote_tomek_HGBoost)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_tomek_HGBoost:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_tomek_HGBoost:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_tomek_HGBoost:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_tomek_HGBoost:.4f}")
print(f"🔹 F1-Score: {f1_smote_tomek_HGBoost:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_tomek_HGBoost:.4f}")

"""## KNeighbors KNN"""

# Definir y entrenar el modelo
model_smote_tomek_KNN = KNeighborsClassifier()
model_smote_tomek_KNN.fit(X_train_smote_tomek,y_train_smote_tomek)

#Predicciones
y_predict_smote_tomek_KNN = model_smote_tomek_KNN.predict(X_test_smote_tomek)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote_tomek,y_predict_smote_tomek_KNN)
print('The accuracy of KNeighborsClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote_tomek,y_predict_smote_tomek_KNN)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['KNeighborsClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_tomek_KNN, FP_smote_tomek_KNN, FN_smote_tomek_KNN, TP_smote_tomek_KNN = confus_matrix.ravel()
print(TN_smote_tomek_KNN, FP_smote_tomek_KNN, FN_smote_tomek_KNN, TP_smote_tomek_KNN)

# Calcular métricas derivadas
accuracy_smote_tomek_KNN = accuracy_score(y_test_smote_tomek, y_predict_smote_tomek_KNN)
precision_smote_tomek_KNN = precision_score(y_test_smote_tomek, y_predict_smote_tomek_KNN)
recall_smote_tomek_KNN = recall_score(y_test_smote_tomek, y_predict_smote_tomek_KNN)
specificity_smote_tomek_KNN = TN / (TN + FP)
f1_smote_tomek_KNN = f1_score(y_test_smote_tomek, y_predict_smote_tomek_KNN)

y_proba_smote_tomek_KNN = model_smote_tomek_KNN.predict_proba(X_test_smote_tomek)[:, 1]
roc_auc_smote_tomek_KNN = roc_auc_score(y_test_smote_tomek, y_proba_smote_tomek_KNN)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_tomek_KNN:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_tomek_KNN:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_tomek_KNN:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_tomek_KNN:.4f}")
print(f"🔹 F1-Score: {f1_smote_tomek_KNN:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_tomek_KNN:.4f}")

"""## Decision tree Application"""

# Definir y entrenar el modelo
model_smote_tomek_DT= DecisionTreeClassifier ()
model_smote_tomek_DT.fit(X_train_smote_tomek,y_train_smote_tomek)

#Predicciones
y_predict_smote_tomek_DT = model_smote_tomek_DT.predict(X_test_smote_tomek)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote_tomek,y_predict_smote_tomek_DT)
print('The accuracy of DecisionTreeClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote_tomek,y_predict_smote_tomek_DT)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['DecisionTreeClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_tomek_DT, FP_smote_tomek_DT, FN_smote_tomek_DT, TP_smote_tomek_DT = confus_matrix.ravel()
print(TN_smote_tomek_DT, FP_smote_tomek_DT, FN_smote_tomek_DT, TP_smote_tomek_DT)

# Calcular métricas derivadas
accuracy_smote_tomek_DT = accuracy_score(y_test_smote_tomek, y_predict_smote_tomek_DT)
precision_smote_tomek_DT = precision_score(y_test_smote_tomek, y_predict_smote_tomek_DT)
recall_smote_tomek_DT = recall_score(y_test_smote_tomek, y_predict_smote_tomek_DT)
specificity_smote_tomek_DT = TN / (TN + FP)
f1_smote_tomek_DT = f1_score(y_test_smote_tomek, y_predict_smote_tomek_DT)

y_proba_smote_tomek_DT = model_smote_tomek_DT.predict_proba(X_test_smote_tomek)[:, 1]
roc_auc_smote_tomek_DT = roc_auc_score(y_test_smote_tomek, y_proba_smote_tomek_DT)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_tomek_DT:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_tomek_DT:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_tomek_DT:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_tomek_DT:.4f}")
print(f"🔹 F1-Score: {f1_smote_tomek_DT:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_tomek_DT:.4f}")

"""## Random Forest"""

# Definir y entrenar el modelo
model_smote_tomek_RF= RandomForestClassifier ()
model_smote_tomek_RF.fit(X_train_smote_tomek,y_train_smote_tomek)

#Predicciones
y_predict_smote_tomek_RF = model_smote_tomek_RF.predict(X_test_smote_tomek)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote_tomek,y_predict_smote_tomek_RF)
print('The accuracy of RandomForestClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote_tomek,y_predict_smote_tomek_RF)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['RandomForestClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_tomek_RF, FP_smote_tomek_RF, FN_smote_tomek_RF, TP_smote_tomek_RF = confus_matrix.ravel()
print(TN_smote_tomek_RF, FP_smote_tomek_RF, FN_smote_tomek_RF, TP_smote_tomek_RF)

# Calcular métricas derivadas
accuracy_smote_tomek_RF = accuracy_score(y_test_smote_tomek, y_predict_smote_tomek_RF)
precision_smote_tomek_RF = precision_score(y_test_smote_tomek, y_predict_smote_tomek_RF)
recall_smote_tomek_RF = recall_score(y_test_smote_tomek, y_predict_smote_tomek_RF)
specificity_smote_tomek_RF = TN / (TN + FP)
f1_smote_tomek_RF = f1_score(y_test_smote_tomek, y_predict_smote_tomek_RF)

y_proba_smote_tomek_RF = model_smote_tomek_RF.predict_proba(X_test_smote_tomek)[:, 1]
roc_auc_smote_tomek_RF = roc_auc_score(y_test_smote_tomek, y_proba_smote_tomek_RF)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_tomek_RF:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_tomek_RF:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_tomek_RF:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_tomek_RF:.4f}")
print(f"🔹 F1-Score: {f1_smote_tomek_RF:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_tomek_RF:.4f}")

"""## Gaussian Naive Bayes Application"""

# Definir y entrenar el modelo
model_smote_tomek_GNB = GaussianNB()
model_smote_tomek_GNB.fit(X_train_smote_tomek,y_train_smote_tomek)

#Predicciones
y_predict_smote_tomek_GNB = model_smote_tomek_GNB.predict(X_test_smote_tomek)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote_tomek,y_predict_smote_tomek_GNB)
print('The accuracy of Logistic Regression is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote_tomek,y_predict_smote_tomek_GNB)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['LogisticRegression'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_tomek_GNB, FP_smote_tomek_GNB, FN_smote_tomek_GNB, TP_smote_tomek_GNB = confus_matrix.ravel()
print(TN_smote_tomek_GNB, FP_smote_tomek_GNB, FN_smote_tomek_GNB, TP_smote_tomek_GNB)

# Calcular métricas derivadas
accuracy_smote_tomek_GNB = accuracy_score(y_test_smote_tomek, y_predict_smote_tomek_GNB)
precision_smote_tomek_GNB = precision_score(y_test_smote_tomek, y_predict_smote_tomek_GNB)
recall_smote_tomek_GNB = recall_score(y_test_smote_tomek, y_predict_smote_tomek_GNB)
specificity_smote_tomek_GNB = TN / (TN + FP)
f1_smote_tomek_GNB = f1_score(y_test_smote_tomek, y_predict_smote_tomek_GNB)

y_proba_smote_tomek_GNB = model_smote_tomek_GNB.predict_proba(X_test_smote_tomek)[:, 1]
roc_auc_smote_tomek_GNB = roc_auc_score(y_test_smote_tomek, y_proba_smote_tomek_GNB)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_tomek_GNB:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_tomek_GNB:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_tomek_GNB:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_tomek_GNB:.4f}")
print(f"🔹 F1-Score: {f1_smote_tomek_GNB:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_tomek_GNB:.4f}")

"""## SVC: (RBF Kernel)"""

# Definir y entrenar el modelo
model_smote_tomek_SVC = SVC()
model_smote_tomek_SVC.fit(X_train_smote_tomek,y_train_smote_tomek)

#Predicciones
y_predict_smote_tomek_SVC = model_smote_tomek_SVC.predict(X_test_smote_tomek)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote_tomek,y_predict_smote_tomek_SVC)
print('The accuracy of SVC is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote_tomek,y_predict_smote_tomek_SVC)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['SVC'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_tomek_SVC, FP_smote_tomek_SVC, FN_smote_tomek_SVC, TP_smote_tomek_SVC = confus_matrix.ravel()
print(TN_smote_tomek_SVC, FP_smote_tomek_SVC, FN_smote_tomek_SVC, TP_smote_tomek_SVC)

# Calcular métricas derivadas
accuracy_smote_tomek_SVC = accuracy_score(y_test_smote_tomek, y_predict_smote_tomek_SVC)
precision_smote_tomek_SVC = precision_score(y_test_smote_tomek, y_predict_smote_tomek_SVC)
recall_smote_tomek_SVC = recall_score(y_test_smote_tomek, y_predict_smote_tomek_SVC)
specificity_smote_tomek_SVC = TN / (TN + FP)
f1_smote_tomek_SVC = f1_score(y_test_smote_tomek, y_predict_smote_tomek_SVC)



# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_tomek_SVC:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_tomek_SVC:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_tomek_SVC:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_tomek_SVC:.4f}")
print(f"🔹 F1-Score: {f1_smote_tomek_SVC:.4f}")

"""## GradientBoostingClassifier"""

# Definir y entrenar el modelo
model_smote_tomek_GBC = GradientBoostingClassifier()
model_smote_tomek_GBC.fit(X_train_smote_tomek,y_train_smote_tomek)

#Predicciones
y_predict_smote_tomek_GBC = model_smote_tomek_GBC.predict(X_test_smote_tomek)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote_tomek,y_predict_smote_tomek_GBC)
print('The accuracy of GradientBoostingClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote_tomek,y_predict_smote_tomek_GBC)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['GradientBoostingClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_tomek_GBC, FP_smote_tomek_GBC, FN_smote_tomek_GBC, TP_smote_tomek_GBC = confus_matrix.ravel()
print(TN_smote_tomek_GBC, FP_smote_tomek_GBC, FN_smote_tomek_GBC, TP_smote_tomek_GBC)

# Calcular métricas derivadas
accuracy_smote_tomek_GBC = accuracy_score(y_test_smote_tomek, y_predict_smote_tomek_GBC)
precision_smote_tomek_GBC = precision_score(y_test_smote_tomek, y_predict_smote_tomek_GBC)
recall_smote_tomek_GBC = recall_score(y_test_smote_tomek, y_predict_smote_tomek_GBC)
specificity_smote_tomek_GBC = TN / (TN + FP)
f1_smote_tomek_GBC = f1_score(y_test_smote_tomek, y_predict_smote_tomek_GBC)

y_proba_smote_tomek_GBC = model_smote_tomek_GBC.predict_proba(X_test_smote_tomek)[:, 1]
roc_auc_smote_tomek_GBC = roc_auc_score(y_test_smote_tomek, y_proba_smote_tomek_GBC)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_tomek_GBC:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_tomek_GBC:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_tomek_GBC:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_tomek_GBC:.4f}")
print(f"🔹 F1-Score: {f1_smote_tomek_GBC:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_tomek_GBC:.4f}")

"""## SGDClassifier"""

# Definir y entrenar el modelo
model_smote_tomek_SGD = SGDClassifier()
model_smote_tomek_SGD.fit(X_train_smote_tomek,y_train_smote_tomek)

#Predicciones
y_predict_smote_tomek_SGD = model_smote_tomek_SGD.predict(X_test_smote_tomek)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote_tomek,y_predict_smote_tomek_SGD)
print('The accuracy of SGDClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote_tomek,y_predict_smote_tomek_SGD)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['SGDClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_tomek_SGD, FP_smote_tomek_SGD, FN_smote_tomek_SGD, TP_smote_tomek_SGD = confus_matrix.ravel()
print(TN_smote_tomek_SGD, FP_smote_tomek_SGD, FN_smote_tomek_SGD, TP_smote_tomek_SGD)

# Calcular métricas derivadas
accuracy_smote_tomek_SGD = accuracy_score(y_test_smote_tomek, y_predict_smote_tomek_SGD)
precision_smote_tomek_SGD = precision_score(y_test_smote_tomek, y_predict_smote_tomek_SGD)
recall_smote_tomek_SGD = recall_score(y_test_smote_tomek, y_predict_smote_tomek_SGD)
specificity_smote_tomek_SGD = TN / (TN + FP)
f1_smote_tomek_SGD = f1_score(y_test_smote_tomek, y_predict_smote_tomek_SGD)




# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_tomek_SGD:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_tomek_SGD:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_tomek_SGD:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_tomek_SGD:.4f}")
print(f"🔹 F1-Score: {f1_smote_tomek_SGD:.4f}")

"""## ExtraTreesClassifier"""

# Definir y entrenar el modelo
model_smote_tomek_EXTRATC = ExtraTreesClassifier()
model_smote_tomek_EXTRATC.fit(X_train_smote_tomek,y_train_smote_tomek)

#Predicciones
y_predict_smote_tomek_EXTRATC = model_smote_tomek_EXTRATC.predict(X_test_smote_tomek)

#Matriz de confusión
accuracy = accuracy_score(y_test_smote_tomek,y_predict_smote_tomek_EXTRATC)
print('The accuracy of EXTRATCClassifier is {:.4f}'.format(accuracy))

confus_matrix = confusion_matrix(y_test_smote_tomek,y_predict_smote_tomek_EXTRATC)
plt.title('Confusion matrix')
sns.heatmap(confus_matrix, annot=True, cmap='Blues', fmt='d')  # Formato entero
plt.xlabel('Predicted class')
plt.ylabel('Exact class');

serie = pd.Series(accuracy,index=['EXTRATCClassifier'])
accuracy_Logmodel = pd.DataFrame({'accuracy':serie})

# Extraer valores de la matriz de confusión
TN_smote_tomek_EXTRATC, FP_smote_tomek_EXTRATC, FN_smote_tomek_EXTRATC, TP_smote_tomek_EXTRATC = confus_matrix.ravel()
print(TN_smote_tomek_EXTRATC, FP_smote_tomek_EXTRATC, FN_smote_tomek_EXTRATC, TP_smote_tomek_EXTRATC)

# Calcular métricas derivadas
accuracy_smote_tomek_EXTRATC = accuracy_score(y_test_smote_tomek, y_predict_smote_tomek_EXTRATC)
precision_smote_tomek_EXTRATC = precision_score(y_test_smote_tomek, y_predict_smote_tomek_EXTRATC)
recall_smote_tomek_EXTRATC = recall_score(y_test_smote_tomek, y_predict_smote_tomek_EXTRATC)
specificity_smote_tomek_EXTRATC = TN / (TN + FP)
f1_smote_tomek_EXTRATC = f1_score(y_test_smote_tomek, y_predict_smote_tomek_EXTRATC)

y_proba_smote_tomek_EXTRATC = model_smote_tomek_EXTRATC.predict_proba(X_test_smote_tomek)[:, 1]
roc_auc_smote_tomek_EXTRATC = roc_auc_score(y_test_smote_tomek, y_proba_smote_tomek_EXTRATC)

# Imprimir resultados
print(f"🔹 Accuracy: {accuracy_smote_tomek_EXTRATC:.4f}")
print(f"🔹 Precision (PPV): {precision_smote_tomek_EXTRATC:.4f}")
print(f"🔹 Recall (Sensibilidad, TPR): {recall_smote_tomek_EXTRATC:.4f}")
print(f"🔹 Specificity (TNR): {specificity_smote_tomek_EXTRATC:.4f}")
print(f"🔹 F1-Score: {f1_smote_tomek_EXTRATC:.4f}")
print(f"🔹 ROC-AUC (Área bajo la curva): {roc_auc_smote_tomek_EXTRATC:.4f}")

"""# Comparación del rendimiento de cada uno de los algoritmos utilizados"""

# Comparación de métricas
metrics_LR = pd.Series({
    "Accuracy": accuracy_LR,
    "Precision": precision_LR,
    "Recall": recall_LR,
    "Specificity": specificity_LR,
    "F1-Score": f1_LR,
    "ROC-AUC": roc_auc_LR
}, name="Logistic Regression")

metrics_HGBoost = pd.Series({
    "Accuracy": accuracy_HGBoost,
    "Precision": precision_HGBoost,
    "Recall": recall_HGBoost,
    "Specificity": specificity_HGBoost,
    "F1-Score": f1_HGBoost,
    "ROC-AUC": roc_auc_HGBoost
}, name="HistGradientBoosting")

metrics_KNN = pd.Series({
    "Accuracy": accuracy_KNN,
    "Precision": precision_KNN,
    "Recall": recall_KNN,
    "Specificity": specificity_KNN,
    "F1-Score": f1_KNN,
    "ROC-AUC": roc_auc_KNN
}, name="KNeighbors Classifier")

metrics_DT = pd.Series({
    "Accuracy": accuracy_DT,
    "Precision": precision_DT,
    "Recall": recall_DT,
    "Specificity": specificity_DT,
    "F1-Score": f1_DT,
    "ROC-AUC": roc_auc_DT
}, name="Decision Tree")

metrics_RF = pd.Series({
    "Accuracy": accuracy_RF,
    "Precision": precision_RF,
    "Recall": recall_RF,
    "Specificity": specificity_RF,
    "F1-Score": f1_RF,
    "ROC-AUC": roc_auc_RF
}, name="Random Forest")

metrics_GNB = pd.Series({
    "Accuracy": accuracy_GNB,
    "Precision": precision_GNB,
    "Recall": recall_GNB,
    "Specificity": specificity_GNB,
    "F1-Score": f1_GNB,
    "ROC-AUC": roc_auc_GNB
}, name="Gaussian Naive Bayes")

metrics_SVC = pd.Series({
    "Accuracy": accuracy_SVC,
    "Precision": precision_SVC,
    "Recall": recall_SVC,
    "Specificity": specificity_SVC,
    "F1-Score": f1_SVC
}, name="SVC")

metrics_GBC = pd.Series({
    "Accuracy": accuracy_GBC,
    "Precision": precision_GBC,
    "Recall": recall_GBC,
    "Specificity": specificity_GBC,
    "F1-Score": f1_GBC,
    "ROC-AUC": roc_auc_GBC
}, name="GradientBoostingClassifier")

metrics_SGD = pd.Series({
    "Accuracy": accuracy_SGD,
    "Precision": precision_SGD,
    "Recall": recall_SGD,
    "Specificity": specificity_SGD,
    "F1-Score": f1_SGD
}, name="SGDClassifier")

metrics_EXTRATC = pd.Series({
    "Accuracy": accuracy_EXTRATC,
    "Precision": precision_EXTRATC,
    "Recall": recall_EXTRATC,
    "Specificity": specificity_EXTRATC,
    "F1-Score": f1_EXTRATC,
    "ROC-AUC": roc_auc_EXTRATC
}, name="ExtraTreesClassifier")

# Metrics for SMOTE balanced data
metrics_smote_LR = pd.Series({
    "Accuracy": accuracy_smote_LR,
    "Precision": precision_smote_LR,
    "Recall": recall_smote_LR,
    "Specificity": specificity_smote_LR,
    "F1-Score": f1_smote_LR,
    "ROC-AUC": roc_auc_smote_LR
}, name="Logistic Regression (SMOTE)")

metrics_smote_HGBoost = pd.Series({
    "Accuracy": accuracy_smote_HGBoost,
    "Precision": precision_smote_HGBoost,
    "Recall": recall_smote_HGBoost,
    "Specificity": specificity_smote_HGBoost,
    "F1-Score": f1_smote_HGBoost,
    "ROC-AUC": roc_auc_smote_HGBoost
}, name="HistGradientBoosting (SMOTE)")

metrics_smote_KNN = pd.Series({
    "Accuracy": accuracy_smote_KNN,
    "Precision": precision_smote_KNN,
    "Recall": recall_smote_KNN,
    "Specificity": specificity_smote_KNN,
    "F1-Score": f1_smote_KNN,
    "ROC-AUC": roc_auc_smote_KNN
}, name="KNeighbors Classifier (SMOTE)")

metrics_smote_DT = pd.Series({
    "Accuracy": accuracy_smote_DT,
    "Precision": precision_smote_DT,
    "Recall": recall_smote_DT,
    "Specificity": specificity_smote_DT,
    "F1-Score": f1_smote_DT,
    "ROC-AUC": roc_auc_smote_DT
}, name="Decision Tree (SMOTE)")

metrics_smote_RF = pd.Series({
    "Accuracy": accuracy_smote_RF,
    "Precision": precision_smote_RF,
    "Recall": recall_smote_RF,
    "Specificity": specificity_smote_RF,
    "F1-Score": f1_smote_RF,
    "ROC-AUC": roc_auc_smote_RF
}, name="Random Forest (SMOTE)")

metrics_smote_GNB = pd.Series({
    "Accuracy": accuracy_smote_GNB,
    "Precision": precision_smote_GNB,
    "Recall": recall_smote_GNB,
    "Specificity": specificity_smote_GNB,
    "F1-Score": f1_smote_GNB,
    "ROC-AUC": roc_auc_smote_GNB
}, name="Gaussian Naive Bayes (SMOTE)")

metrics_smote_SVC = pd.Series({
    "Accuracy": accuracy_smote_SVC,
    "Precision": precision_smote_SVC,
    "Recall": recall_smote_SVC,
    "Specificity": specificity_smote_SVC,
    "F1-Score": f1_smote_SVC
}, name="SVC (SMOTE)")

metrics_smote_GBC = pd.Series({
    "Accuracy": accuracy_smote_GBC,
    "Precision": precision_smote_GBC,
    "Recall": recall_smote_GBC,
    "Specificity": specificity_smote_GBC,
    "F1-Score": f1_smote_GBC,
    "ROC-AUC": roc_auc_smote_GBC
}, name="GradientBoostingClassifier (SMOTE)")

metrics_smote_SGD = pd.Series({
    "Accuracy": accuracy_smote_SGD,
    "Precision": precision_smote_SGD,
    "Recall": recall_smote_SGD,
    "Specificity": specificity_smote_SGD,
    "F1-Score": f1_smote_SGD
}, name="SGDClassifier (SMOTE)")

metrics_smote_EXTRATC = pd.Series({
    "Accuracy": accuracy_smote_EXTRATC,
    "Precision": precision_smote_EXTRATC,
    "Recall": recall_smote_EXTRATC,
    "Specificity": specificity_smote_EXTRATC,
    "F1-Score": f1_smote_EXTRATC,
    "ROC-AUC": roc_auc_smote_EXTRATC
}, name="ExtraTreesClassifier (SMOTE)")

# Metrics for RUS balanced data
metrics_rus_LR = pd.Series({
    "Accuracy": accuracy_rus_LR,
    "Precision": precision_rus_LR,
    "Recall": recall_rus_LR,
    "Specificity": specificity_rus_LR,
    "F1-Score": f1_rus_LR,
    "ROC-AUC": roc_auc_rus_LR
}, name="Logistic Regression (RUS)")

metrics_rus_HGBoost = pd.Series({
    "Accuracy": accuracy_rus_HGBoost,
    "Precision": precision_rus_HGBoost,
    "Recall": recall_rus_HGBoost,
    "Specificity": specificity_rus_HGBoost,
    "F1-Score": f1_rus_HGBoost,
    "ROC-AUC": roc_auc_rus_HGBoost
}, name="HistGradientBoosting (RUS)")

metrics_rus_KNN = pd.Series({
    "Accuracy": accuracy_rus_KNN,
    "Precision": precision_rus_KNN,
    "Recall": recall_rus_KNN,
    "Specificity": specificity_rus_KNN,
    "F1-Score": f1_rus_KNN,
    "ROC-AUC": roc_auc_rus_KNN
}, name="KNeighbors Classifier (RUS)")

metrics_rus_DT = pd.Series({
    "Accuracy": accuracy_rus_DT,
    "Precision": precision_rus_DT,
    "Recall": recall_rus_DT,
    "Specificity": specificity_rus_DT,
    "F1-Score": f1_rus_DT,
    "ROC-AUC": roc_auc_rus_DT
}, name="Decision Tree (RUS)")

metrics_rus_RF = pd.Series({
    "Accuracy": accuracy_rus_RF,
    "Precision": precision_rus_RF,
    "Recall": recall_rus_RF,
    "Specificity": specificity_rus_RF,
    "F1-Score": f1_rus_RF,
    "ROC-AUC": roc_auc_rus_RF
}, name="Random Forest (RUS)")

metrics_rus_GNB = pd.Series({
    "Accuracy": accuracy_rus_GNB,
    "Precision": precision_rus_GNB,
    "Recall": recall_rus_GNB,
    "Specificity": specificity_rus_GNB,
    "F1-Score": f1_rus_GNB,
    "ROC-AUC": roc_auc_rus_GNB
}, name="Gaussian Naive Bayes (RUS)")

metrics_rus_SVC = pd.Series({
    "Accuracy": accuracy_rus_SVC,
    "Precision": precision_rus_SVC,
    "Recall": recall_rus_SVC,
    "Specificity": specificity_rus_SVC,
    "F1-Score": f1_rus_SVC
}, name="SVC (RUS)")

metrics_rus_GBC = pd.Series({
    "Accuracy": accuracy_rus_GBC,
    "Precision": precision_rus_GBC,
    "Recall": recall_rus_GBC,
    "Specificity": specificity_rus_GBC,
    "F1-Score": f1_rus_GBC,
    "ROC-AUC": roc_auc_rus_GBC
}, name="GradientBoostingClassifier (RUS)")

metrics_rus_SGD = pd.Series({
    "Accuracy": accuracy_rus_SGD,
    "Precision": precision_rus_SGD,
    "Recall": recall_rus_SGD,
    "Specificity": specificity_rus_SGD,
    "F1-Score": f1_rus_SGD
}, name="SGDClassifier (RUS)")

metrics_rus_EXTRATC = pd.Series({
    "Accuracy": accuracy_rus_EXTRATC,
    "Precision": precision_rus_EXTRATC,
    "Recall": recall_rus_EXTRATC,
    "Specificity": specificity_rus_EXTRATC,
    "F1-Score": f1_rus_EXTRATC,
    "ROC-AUC": roc_auc_rus_EXTRATC
}, name="ExtraTreesClassifier (RUS)")

# Metrics for SMOTE-Tomek balanced data
metrics_smote_tomek_LR = pd.Series({
    "Accuracy": accuracy_smote_tomek_LR,
    "Precision": precision_smote_tomek_LR,
    "Recall": recall_smote_tomek_LR,
    "Specificity": specificity_smote_tomek_LR,
    "F1-Score": f1_smote_tomek_LR,
    "ROC-AUC": roc_auc_smote_tomek_LR
}, name="Logistic Regression (SMOTE-Tomek)")

metrics_smote_tomek_HGBoost = pd.Series({
    "Accuracy": accuracy_smote_tomek_HGBoost,
    "Precision": precision_smote_tomek_HGBoost,
    "Recall": recall_smote_tomek_HGBoost,
    "Specificity": specificity_smote_tomek_HGBoost,
    "F1-Score": f1_smote_tomek_HGBoost,
    "ROC-AUC": roc_auc_smote_tomek_HGBoost
}, name="HistGradientBoosting (SMOTE-Tomek)")

metrics_smote_tomek_KNN = pd.Series({
    "Accuracy": accuracy_smote_tomek_KNN,
    "Precision": precision_smote_tomek_KNN,
    "Recall": recall_smote_tomek_KNN,
    "Specificity": specificity_smote_tomek_KNN,
    "F1-Score": f1_smote_tomek_KNN,
    "ROC-AUC": roc_auc_smote_tomek_KNN
}, name="KNeighbors Classifier (SMOTE-Tomek)")

metrics_smote_tomek_DT = pd.Series({
    "Accuracy": accuracy_smote_tomek_DT,
    "Precision": precision_smote_tomek_DT,
    "Recall": recall_smote_tomek_DT,
    "Specificity": specificity_smote_tomek_DT,
    "F1-Score": f1_smote_tomek_DT,
    "ROC-AUC": roc_auc_smote_tomek_DT
}, name="Decision Tree (SMOTE-Tomek)")

metrics_smote_tomek_RF = pd.Series({
    "Accuracy": accuracy_smote_tomek_RF,
    "Precision": precision_smote_tomek_RF,
    "Recall": recall_smote_tomek_RF,
    "Specificity": specificity_smote_tomek_RF,
    "F1-Score": f1_smote_tomek_RF,
    "ROC-AUC": roc_auc_smote_tomek_RF
}, name="Random Forest (SMOTE-Tomek)")

metrics_smote_tomek_GNB = pd.Series({
    "Accuracy": accuracy_smote_tomek_GNB,
    "Precision": precision_smote_tomek_GNB,
    "Recall": recall_smote_tomek_GNB,
    "Specificity": specificity_smote_tomek_GNB,
    "F1-Score": f1_smote_tomek_GNB,
    "ROC-AUC": roc_auc_smote_tomek_GNB
}, name="Gaussian Naive Bayes (SMOTE-Tomek)")

metrics_smote_tomek_SVC = pd.Series({
    "Accuracy": accuracy_smote_tomek_SVC,
    "Precision": precision_smote_tomek_SVC,
    "Recall": recall_smote_tomek_SVC,
    "Specificity": specificity_smote_tomek_SVC,
    "F1-Score": f1_smote_tomek_SVC
}, name="SVC (SMOTE-Tomek)")

metrics_smote_tomek_GBC = pd.Series({
    "Accuracy": accuracy_smote_tomek_GBC,
    "Precision": precision_smote_tomek_GBC,
    "Recall": recall_smote_tomek_GBC,
    "Specificity": specificity_smote_tomek_GBC,
    "F1-Score": f1_smote_tomek_GBC,
    "ROC-AUC": roc_auc_smote_tomek_GBC
}, name="GradientBoostingClassifier (SMOTE-Tomek)")

metrics_smote_tomek_SGD = pd.Series({
    "Accuracy": accuracy_smote_tomek_SGD,
    "Precision": precision_smote_tomek_SGD,
    "Recall": recall_smote_tomek_SGD,
    "Specificity": specificity_smote_tomek_SGD,
    "F1-Score": f1_smote_tomek_SGD
}, name="SGDClassifier (SMOTE-Tomek)")

metrics_smote_tomek_EXTRATC = pd.Series({
    "Accuracy": accuracy_smote_tomek_EXTRATC,
    "Precision": precision_smote_tomek_EXTRATC,
    "Recall": recall_smote_tomek_EXTRATC,
    "Specificity": specificity_smote_tomek_EXTRATC,
    "F1-Score": f1_smote_tomek_EXTRATC,
    "ROC-AUC": roc_auc_smote_tomek_EXTRATC
}, name="ExtraTreesClassifier (SMOTE-Tomek)")


# Combine all metrics into a single DataFrame
accuracy_models = pd.concat([
    metrics_LR, metrics_HGBoost, metrics_KNN, metrics_DT, metrics_RF,
    metrics_GNB, metrics_SVC, metrics_GBC, metrics_SGD, metrics_EXTRATC,
    metrics_smote_LR, metrics_smote_HGBoost, metrics_smote_KNN, metrics_smote_DT, metrics_smote_RF,
    metrics_smote_GNB, metrics_smote_SVC, metrics_smote_GBC, metrics_smote_SGD, metrics_smote_EXTRATC,
    metrics_rus_LR, metrics_rus_HGBoost, metrics_rus_KNN, metrics_rus_DT, metrics_rus_RF,
    metrics_rus_GNB, metrics_rus_SVC, metrics_rus_GBC, metrics_rus_SGD, metrics_rus_EXTRATC,
    metrics_smote_tomek_LR, metrics_smote_tomek_HGBoost, metrics_smote_tomek_KNN, metrics_smote_tomek_DT, metrics_smote_tomek_RF,
    metrics_smote_tomek_GNB, metrics_smote_tomek_SVC, metrics_smote_tomek_GBC, metrics_smote_tomek_SGD, metrics_smote_tomek_EXTRATC
], axis=1).T

# Display the comparison table
display(accuracy_models)

"""# Interacción con el Modelo:

"""

#Leer el DataSet para experimento
data_diabetes_exp = pd.read_csv('diabetes_dataset_clinica.csv')
data_diabetes_exp

data_diabetes_exp["gender"].value_counts()

# Create a copy of the DataFrame experimento para no modificar los datos originales directamente
data_encoded_exp = data_diabetes_exp.copy()

# Aplica One-Hot Encoding a las columnas especificadas, conservando todas las categorías
data_encoded_exp = pd.get_dummies(data_encoded_exp, columns=['gender', 'ethnicity', 'smoking_status'], drop_first=False, dtype=int)

# Mueve la columna 'diagnosed_diabetes' al final
diagnosed_diabetes_col = data_encoded_exp.pop('diagnosed_diabetes')
data_encoded_exp['diagnosed_diabetes'] = diagnosed_diabetes_col

# Muestra las primeras filas del DataFrame codificado
print("Primeras filas del DataFrame 'data_encoded_exp' después de la codificación one-hot numérica y reordenación de columna:")
display(data_encoded_exp.head())

X_eval = data_encoded_exp.drop(['diagnosed_diabetes'],axis=1)
y_eval = data_encoded_exp['diagnosed_diabetes']

"""Evaluacion modelo 1: _smote_tomek_Random Forest"""

#Evaluación con Random Forest (Smote-Tomek)
y_eval_smote_tomek_RF = model_smote_tomek_RF.predict(X_eval)
accuracy_eval_smote_tomek_RF = accuracy_score(y_eval,y_eval_smote_tomek_RF)
print('La exactitud de GradientBoostingClassifier es {:.4f}'.format(accuracy_eval_smote_tomek_RF ))

"""Evaluacion modelo 2: _smote_tomek_Gradient_Boosting"""

#Evaluación con Gradient Boosting Classifier (Smote-Tomek)
y_eval_smote_tomek_GBC = model_smote_tomek_GBC.predict(X_eval)
accuracy_eval_smote_tomek_GBC = accuracy_score(y_eval,y_eval_smote_tomek_GBC)
print('La exactitud de GradientBoostingClassifier es {:.4f}'.format(accuracy_eval_smote_tomek_GBC ))

"""Evaluacion modelo 3: smote_tomek_HistGradientBoosting"""

#Evaluación con HistGradientBoosting Classifier (Smote-Tomek)
y_eval_smote_tomek_HGBoost = model_smote_tomek_HGBoost.predict(X_eval)
accuracy_eval_smote_tomek_HGBoost = accuracy_score(y_eval,y_eval_smote_tomek_HGBoost)
print('La exactitud de GradientBoostingClassifier es {:.4f}'.format(accuracy_eval_smote_tomek_HGBoost ))



# ==========================================
# OPCIÓN: MODO AUTOMÁTICO O MANUAL
# ==========================================
print("¿Cómo deseas ingresar los datos?")
print("1. Automático (con valores de ejemplo)")
print("2. Manual (ingresar cada valor)")
modo = input("Selecciona (1 o 2): ")

if modo == "1":
    # EJEMPLO AUTOMÁTICO - Paciente de prueba
    print("\n✓ Usando datos de ejemplo...\n")

    # Variables numéricas
    age = 45.0
    income_level = 2.0
    alcohol_consumption_per_week = 3.0
    physical_activity_minutes_per_week = 150.0
    diet_score = 7.0
    sleep_hours_per_day = 7.0
    screen_time_hours_per_day = 4.0
    family_history_diabetes = 1.0
    hypertension_history = 0.0
    cardiovascular_history = 0.0
    bmi = 28.5
    waist_to_hip_ratio = 0.95
    systolic_bp = 130.0
    diastolic_bp = 85.0
    heart_rate = 75.0
    cholesterol_total = 200.0
    hdl_cholesterol = 45.0
    ldl_cholesterol = 130.0
    triglycerides = 150.0
    glucose_fasting = 110.0
    glucose_postprandial = 140.0
    insulin_level = 15.0
    hba1c = 5.8
    diabetes_risk_score = 6.5

    # Variables categóricas
    gender_Female, gender_Male = 0, 1
    ethnicity_Asian, ethnicity_Black, ethnicity_Hispanic, ethnicity_Other, ethnicity_White = 0, 0, 1, 0, 0
    smoking_status_Current, smoking_status_Former, smoking_status_Never = 0, 1, 0

else:
    # MODO MANUAL
    print("\n--- INGRESO MANUAL DE DATOS ---\n")

    age = float(input("Edad en años: "))

    # GÉNERO
    print("\nGÉNERO: 1.Female | 2.Male")
    g = input("Selecciona: ")
    gender_Female, gender_Male = (1, 0) if g == "1" else (0, 1)

    # ETNICIDAD
    print("\nETNICIDAD: 1.Asian | 2.Black | 3.Hispanic | 4.Other | 5.White")
    e = input("Selecciona: ")
    ethnicities = {'1': (1,0,0,0,0), '2': (0,1,0,0,0), '3': (0,0,1,0,0),
                   '4': (0,0,0,1,0), '5': (0,0,0,0,1)}
    ethnicity_Asian, ethnicity_Black, ethnicity_Hispanic, ethnicity_Other, ethnicity_White = ethnicities.get(e, (0,0,0,0,0))

    # FUMADO
    print("\nFUMADO: 1.Current | 2.Former | 3.Never")
    s = input("Selecciona: ")
    smoking = {'1': (1,0,0), '2': (0,1,0), '3': (0,0,1)}
    smoking_status_Current, smoking_status_Former, smoking_status_Never = smoking.get(s, (0,0,0))

    income_level = float(input("\nNivel de ingresos (0-4): "))
    alcohol_consumption_per_week = float(input("Consumo de alcohol por semana (copas): "))
    physical_activity_minutes_per_week = float(input("Actividad física por semana (minutos): "))
    diet_score = float(input("Calidad de dieta (1-10): "))
    sleep_hours_per_day = float(input("Horas de sueño por día: "))
    screen_time_hours_per_day = float(input("Tiempo en pantalla por día (horas): "))
    family_history_diabetes = float(input("Historia familiar de diabetes (0=No, 1=Sí): "))
    hypertension_history = float(input("Historia de hipertensión (0=No, 1=Sí): "))
    cardiovascular_history = float(input("Historia cardiovascular (0=No, 1=Sí): "))
    bmi = float(input("IMC (kg/m²): "))
    waist_to_hip_ratio = float(input("Relación cintura-cadera: "))
    systolic_bp = float(input("Presión sistólica: "))
    diastolic_bp = float(input("Presión diastólica: "))
    heart_rate = float(input("Frecuencia cardíaca: "))
    cholesterol_total = float(input("Colesterol total: "))
    hdl_cholesterol = float(input("Colesterol HDL: "))
    ldl_cholesterol = float(input("Colesterol LDL: "))
    triglycerides = float(input("Triglicéridos: "))
    glucose_fasting = float(input("Glucosa en ayunas: "))
    glucose_postprandial = float(input("Glucosa postprandial: "))
    insulin_level = float(input("Nivel de insulina: "))
    hba1c = float(input("HbA1c: "))
    diabetes_risk_score = float(input("Score de riesgo de diabetes: "))

# ==========================================
# CREAR DATAFRAME CON EL ORDEN CORRECTO
# ==========================================
patient_data = pd.DataFrame({
    'age': [age],
    'income_level': [income_level],
    'alcohol_consumption_per_week': [alcohol_consumption_per_week],
    'physical_activity_minutes_per_week': [physical_activity_minutes_per_week],
    'diet_score': [diet_score],
    'sleep_hours_per_day': [sleep_hours_per_day],
    'screen_time_hours_per_day': [screen_time_hours_per_day],
    'family_history_diabetes': [family_history_diabetes],
    'hypertension_history': [hypertension_history],
    'cardiovascular_history': [cardiovascular_history],
    'bmi': [bmi],
    'waist_to_hip_ratio': [waist_to_hip_ratio],
    'systolic_bp': [systolic_bp],
    'diastolic_bp': [diastolic_bp],
    'heart_rate': [heart_rate],
    'cholesterol_total': [cholesterol_total],
    'hdl_cholesterol': [hdl_cholesterol],
    'ldl_cholesterol': [ldl_cholesterol],
    'triglycerides': [triglycerides],
    'glucose_fasting': [glucose_fasting],
    'glucose_postprandial': [glucose_postprandial],
    'insulin_level': [insulin_level],
    'hba1c': [hba1c],
    'diabetes_risk_score': [diabetes_risk_score],
    'gender_Female': [gender_Female],
    'gender_Male': [gender_Male],
    'ethnicity_Asian': [ethnicity_Asian],
    'ethnicity_Black': [ethnicity_Black],
    'ethnicity_Hispanic': [ethnicity_Hispanic],
    'ethnicity_Other': [ethnicity_Other],
    'ethnicity_White': [ethnicity_White],
    'smoking_status_Current': [smoking_status_Current],
    'smoking_status_Former': [smoking_status_Former],
    'smoking_status_Never': [smoking_status_Never]
})

print("\n" + "="*50)
print("DATOS DEL PACIENTE PREPARADOS")
print("="*50)
print(patient_data.T)

# ==========================================
# PREDICCIÓN (ASEGÚRATE DE TENER TU MODELO CARGADO)
# ==========================================
prediccion = model_smote_tomek_HGBoost.predict(patient_data)
probabilidades = model_smote_tomek_HGBoost.predict_proba(patient_data)
prediccion_1 = model_smote_tomek_RF.predict(patient_data)
probabilidades_1 = model_smote_tomek_RF.predict_proba(patient_data)
prediccion_2 = model_smote_tomek_GBC.predict(patient_data)
probabilidades_2 = model_smote_tomek_GBC.predict_proba(patient_data)
print(f"\n--- Resultado de la Predicción ---")
print(f"Predicción: {prediccion[0]}")
print(f"Probabilidad NO DIABETES: {probabilidades[0][0]:.4f}")
print(f"Probabilidad DIABETES: {probabilidades[0][1]:.4f}")

print(f"\n--- Resultado de la Predicción ---")
print(f"Predicción: {prediccion_1[0]}")
print(f"Probabilidad NO DIABETES: {probabilidades_1[0][0]:.4f}")
print(f"Probabilidad DIABETES: {probabilidades_1[0][1]:.4f}")

print(f"\n--- Resultado de la Predicción ---")
print(f"Predicción: {prediccion_2[0]}")
print(f"Probabilidad NO DIABETES: {probabilidades_2[0][0]:.4f}")
print(f"Probabilidad DIABETES: {probabilidades_2[0][1]:.4f}")